plot(Polygon(Luzon.polygon@coords))
as_sf(Polygon(Luzon.polygon@coords))
sf::as_sf(Polygon(Luzon.polygon@coords))
ggplot2::as_sf(Polygon(Luzon.polygon@coords))
sf::st_sf(Polygon(Luzon.polygon@coords))
ggplot2::geom_polygon(Polygon(Luzon.polygon@coords))
ggplot2::geom_polygon(Polygon(Luzon.polygon@coords))
ph.df <- data.frame(x=Luzon.polygon@coords[,1],y=Luzon.polygon@coords[,2],island=1)
ph.df
ggplot2::ggplot() + ggplot2::geom_polygon(ph.df,aes(x=x,y=y))
ggplot2::ggplot() + ggplot2::geom_polygon(ph.df,ggplot2::aes(x=x,y=y))
library(ggplot2)
ggplot2::ggplot() + ggplot2::geom_polygon(ph.df,mapping=ggplot2::aes(x=x,y=y))
wnd= c(-180, 180,-90, 90)
wnd
raster::extent(wnd)
extent(wnd)
test.sp <- as(ph.df, "SpatialPolygons")
test.sp <- as(Luzon.polygon, "SpatialPolygons")
test.sp <- as(extent(Luzon.polygon), "SpatialPolygons")
test.sp <- as(extent(Luzon.polygon@coords), "SpatialPolygons")
test.sp <- as(raster::extent(Luzon.polygon@coords), "SpatialPolygons")
test.sp
?raster::extent
?SpatialPolygons()
test.sp <- as(list(Luzon.polygon), "SpatialPolygons")
test.sp <- SpatialPolygons(list(Luzon.polygon))
test.sp <- SpatialPolygons(Polygons(Luzon.polygon))
test.sp <- SpatialPolygons(list(Polygons(list(Luzon.polygon))))
test.sp <- SpatialPolygons(list(Polygons(list(Luzon.polygon),1)))
plot(test.sp)
world.land.sp    <- rnaturalearth::ne_countries(scale=110, returnclass="sp")
ph.land10.sp     <- world.land10.sp[which(world.land10.sp[,"sovereignt"][[1]]=="Philippines"),]
ph.island.areas  <- sapply(X=1:length(ph.land10.sp@polygons[[1]]@Polygons),FUN=function(x){ph.land10.sp@polygons[[1]]@Polygons[[x]]@area})
Luzon.polygon    <- ph.land10.sp@polygons[[1]]@Polygons[[which(ph.island.areas == max(ph.island.areas))]]
test.sp          <- SpatialPolygons(list(Polygons(list(Luzon.polygon),1)))
Luzon.sp          <- SpatialPolygons(list(Polygons(list(Luzon.polygon),1)))
plot(Luzon.sp)
raster::crs(Luzon.sp) <- sp::CRS("EPSG:4326")
wnd.sp           <- Luzon.sp
wnd.sp               <- Luzon.sp
raster::crs(wnd.sp2) <- sp::CRS("EPSG:4326")#
				wnd.area             <- wnd.sp2@polygons[[1]]@Polygons[[1]]@area
raster::crs(wnd.sp)  <- sp::CRS("EPSG:4326")#
				wnd.area             <- wnd.sp@polygons[[1]]@Polygons[[1]]@area
wnd.area
regionsize=1
regionsize.dd0       <- (regionsize*wnd.area)#
				regionsize.dd        <- (regionsize.dd0*0.25)
wnd <- Luzon.sp#
				# wnd.sp is simply wnd#
				wnd.sp <- wnd#
				raster::crs(wnd.sp)  <- sp::CRS("EPSG:4326")#
				wnd.area             <- wnd.sp@polygons[[1]]@Polygons[[1]]@area#
				regionsize.dd0       <- (regionsize*wnd.area)#
				regionsize.dd        <- (regionsize.dd0*0.25)
samplesize=100; n.grp=2; grp.n.weights=NULL; grp.area.weights=NULL; min.grp.size=2; wnd=Luzon.sp; over.land=TRUE; interactions=c(0,1); show.plot=TRUE; return.as="data.frame"
if(is.null(grp.n.weights)){#
		grp.n.weights <- rep(1,n.grp)#
	}#
	if(is.null(grp.area.weights)){#
		grp.area.weights <- rep(1,n.grp)#
	}#
	# Number > 0 that scales geographical areas of all groups relative to 'regionsize'*(area of 'wnd')#
	grp.scaler=(1/n.grp)#
	# Adding this soon. Plan is to convert each bounding box to an extent object and then Polygon object, and then combine into SpatialPolygons for multi-part areas.
grp.scaler.start <- grp.scaler#
	#result.temp        <- data.frame(NULL)#
	PASS=FALSE#
	miter <- 100#
	ctr   <- 0#
	if(length(samplesize)==1){#
		if((n.grp*min.grp.size) > samplesize){#
			stop("Total sample size 'samplesize' must be greater than the number of groups 'n.grp' times minimum group size 'min.grp.size'.",call.=FALSE)#
		}#
	} else {#
		if(length(samplesize)!=n.grp){#
			stop("If 'samplesize' is a numerical vector, then it must have a length equal to the number of groups 'n.grp'.",call.=FALSE)#
		}#
	}
is(wnd,"matrix")
is(wnd,"SpatialPolygons")
while(!PASS){#
		ctr <- ctr + 1#
		if(ctr > miter){#
			stop(paste("after",miter,"attemps, failed to find points that pass conditions. ctr=",ctr,"ctr2=",ctr2,"; grp.scaler=",grp.scaler))#
		}#
		#if(ctr %in% seq(from=10,to=miter,by=10)){#
		if(ctr>1){#
			grp.scaler <- (grp.scaler*0.95)#
		}#
		### Clear the data frame if too few points on land during previous attempt#
		#result.temp         <- data.frame(NULL)#
		initial <- FALSE#
		### Find group centers that pass conditions#
		ctr2 <- 0#
		while(!initial){#
			ctr2 <- ctr2 + 1#
			if(ctr2 > (miter/10)){#
				break#
				# stop(paste("failed to initialize after",miter,"attemps. ctr=",ctr,"ctr2=",ctr2))#
			}#
			if(ctr2>1){#
				grp.scaler <- (grp.scaler*0.99)#
			}#
			# Random point within wnd.sp to determine subregion within which group centers will occur#
			center.sp <- sp::spsample(wnd.sp,n=1,type="random")#
			# Length two vector with "x" and "y" entries from sample.center, to pass to spCircle#
			center.xy <- c(sp::coordinates(center.sp)); names(center.xy) <- c("x","y")#
			# Create a circular polygon centered at sample center; in this case #
			# sample.area.sp <- sampSurf::spCircle(radius=sqrt((regionsize/pi)),centerPoint=center.xy)[[1]]#
			# regionsize2 <- (10^regionsize)#
			# regionsize2 <- regionsize.dd#
			#if(n.grp==1){#
			#regionsize.dd <- (regionsize.dd*grp.scaler*0.5)#
			#}#
			sample.area.sp <- sampSurf::spCircle(radius=sqrt((regionsize.dd/pi)), centerPoint=center.xy)[[1]]#
			#sample.area.sp.area <- attributes(attributes(attributes(sample.area.sp)$polygons[[1]])[[1]][[1]])$area#
			# Check if entire sample.area.sp is within window defined by 'wnd' argument#
	#		area.wnd.diff <- rgeos::gDifference(spgeom1=sample.area.sp,spgeom2=wnd.sp)#
	#		# If area.wnd.diff is not NULL, then part of 'sample.area.sp' falls outside of the sampling window.#
	#		if(!is.null(area.wnd.diff)){#
	#			next#
	#		}#
			if(n.grp>1){#
				# Sample group sampling-center locations from within sample.area.sp#
				grp.pts <- sp::spsample(sample.area.sp,n=n.grp,type="random")#
				# coordinates extracted from grp.pts#
				grp.pts.mat <- sp::coordinates(grp.pts)#
				colnames(grp.pts.mat) <- c("x","y")#
				grp.areas <- (regionsize.dd*(grp.area.weights/(sum(grp.area.weights)))*grp.scaler)#
				# create polygons centered at grp.pts, from which each groups points will be drawn. First need to determine group sizes...#
				grp.areas.sp <- lapply(X=1:n.grp, FUN=function(x){sampSurf::spCircle(radius=sqrt((grp.areas/pi))[x],centerPoint=c(grp.pts.mat[x,]))[[1]]})#
				# Distance between group centers. Not sure if this is necessary.#
				# geodist(grp.pts.mat,measure="geodesic")#
				grp.center.dists0 <- geodist::geodist(grp.pts.mat,measure="geodesic")#
				grp.center.dists  <- grp.center.dists0[lower.tri(grp.center.dists0)]#
				# check that each group centers occur over land, if over.land is true#
			} else {#
				grp.pts.mat  <- matrix(center.xy,nrow=1,dimnames=list(c(NULL),c("x","y")))#
				grp.areas.sp <- list(sample.area.sp)#
			}#
			if(over.land){#
				if(length(points.on.land(x=grp.pts.mat)[,1]) < n.grp){#
				#if(length(points.on.land(x=sp::coordinates(grp.pts))[,1]) < n.grp){#
					next#
				}#
			}#
			initial <- TRUE#
		}#
		### For each group, the number of samples that will be drawn (or saved, if over.land=TRUE) from the group's sample region.#
		if(length(samplesize)==1){#
			if(n.grp==1){#
				grp.sizes <- samplesize#
			} else {#
				# Initial values for entering while loop#
				grp.sizes <- rep(0,n.grp)#
				while(any(grp.sizes < min.grp.size)){#
					grp.sizes  <- c(table(sample(x=c(1:n.grp),size=samplesize,prob=grp.n.weights,replace=TRUE)))#
					# verify that at least each group has at least min.grp.size.#
				}#
			}#
		} else {#
			grp.sizes <- samplesize#
		}#
		# grp.sizes <- round(samplesize * (grp.n.weights/sum(grp.n.weights)))#
		### Creates a SpatialPolygons object (sampling region) for each group#
		#sample.area.sp <- lapply(1:n.grp, FUN=function(x){sampSurf::spCircle(radius= sqrt((grp.areas/pi))[x] , centerPoint=c(x=group.centers[x,1],y=group.centers[x,2]))[[1]]})#
		### Check if groups meet conditions set by 'interactions' argument.#
		if(!is.null(interactions) & n.grp > 1){#
			if(!(interactions[1]==0 & interactions[2]==1)){#
				# Much less complex list holding the sample sampling polygons#
				# polygons.list <- lapply(X=1:n.grp, function(x){attributes(attributes(grp.areas.sp[[x]])$"polygons"[[1]])[[1]][[1]]})#
				# Possibly equivalent:#
				polygons.list <- lapply(X=1:n.grp, function(x) grp.areas.sp[[x]]@polygons[[1]]@Polygons[[1]])#
				# All possible pairwise group comparisons#
				grp.pairs <- do.call(rbind,pset(1:n.grp,2,2))#
				# Calculate intersect area yet and sum areas for each pair of groups. (Doesnt work yet).#
				grp.int.area <- grp.sum.area <- grp.ratio <- c()#
				for(i in 1:nrow(grp.pairs)){#
					polygon.pair   <- polygons.list[c(grp.pairs[i,1],grp.pairs[i,2])]#
					grp1.area.temp <- polygon.pair[[1]]@area#
					grp2.area.temp <- polygon.pair[[2]]@area#
					pairsum.temp   <- sum(c(grp1.area.temp, grp2.area.temp))#
					#grp.int <- raster::intersect(sample.area.sp[[grp.pairs[i,1]]], sample.area.sp[[grp.pairs[i,2]]])#
					# returns NULL if polygons do not intersect; returns SpatialPolygons object if they do intersect#
					grp.int  <- rgeos::gIntersection(spgeom1=grp.areas.sp[[grp.pairs[i,1]]],spgeom2=grp.areas.sp[[grp.pairs[i,2]]])#
					#Nonintersecting portions of areas 1 and 2 (faster than getting diff of each in the other and then adding)#
					#grp.diff <- rgeos::gSymdifference(spgeom1=grp.areas.sp[[grp.pairs[i,1]]],spgeom2=grp.areas.sp[[grp.pairs[i,2]]])#
					# returns a spatial polygons object with the non-intersecting portions of the group pair polygons each as their own polygons. If no overlap the returned polygons are the same the input polygons.#
					grp.diff1 <- rgeos::gDifference(spgeom1=grp.areas.sp[[grp.pairs[i,1]]],spgeom2=grp.areas.sp[[grp.pairs[i,2]]])#
					grp.diff2 <- rgeos::gDifference(spgeom1=grp.areas.sp[[grp.pairs[i,2]]],spgeom2=grp.areas.sp[[grp.pairs[i,1]]])#
					if(is.null(grp.int)){#
						int.area.temp <- 0#
					} else {#
						#int.area.temp <- attributes(attributes(attributes(grp.int)$"polygons"[[1]])[[1]][[1]])$area#
						int.area.temp <- grp.int@polygons[[1]]@Polygons[[1]]@area#
#
					}#
					# Area of the region of group 1 that does not intersect group 2 (for this pair of groups).#
					if(is.null(grp.diff1)){#
						diff1.area.temp <- 0#
					} else {#
						#diff1.area.temp <- attributes(attributes(attributes(grp.diff1)$"polygons"[[1]])[[1]][[1]])$area#
						diff1.area.temp <- grp.diff1@polygons[[1]]@Polygons[[1]]@area#
					}#
					if(is.null(grp.diff2)){#
						diff2.area.temp <- 0#
					} else {#
						#diff2.area.temp <- attributes(attributes(attributes(grp.diff2)$"polygons"[[1]])[[1]][[1]])$area#
						diff2.area.temp <- grp.diff2@polygons[[1]]@Polygons[[1]]@area#
					}#
					#if(is.null(grp.diff)){#
					#	diff.area.temp <- 0#
					#} else {#
					#	diff1.area.temp <- attributes(attributes(attributes(grp.diff)$"polygons"[[1]])[[1]][[1]])$area#
					#	diff2.area.temp <- attributes(attributes(attributes(grp.diff)$"polygons"[[1]])[[1]][[2]])$area#
					#}#
					diff.area.temp  <- diff1.area.temp + diff2.area.temp#
					ratio.temp <- int.area.temp/diff.area.temp#
					#ratio.temp <- (int.area.temp/pairsum.temp)#
					#grp.int <- raster::intersect(spgeom1=sample.area.sp[[1]],spgeom2=sample.area.sp[[2]])#
					grp.int.area <- c(grp.int.area,int.area.temp)#
					grp.sum.area <- c(grp.sum.area,pairsum.temp)#
					grp.ratio    <- c(grp.ratio,ratio.temp)#
				}#
				area.df <- data.frame(group.i=grp.pairs[,1],group.j=grp.pairs[,2],area.intersection=grp.int.area,area.sumpair=grp.sum.area,area.intersection.sum.ratio=grp.ratio)#
				# Check that the required conditions for interactions are met#
				if(!all(area.df$area.intersection.sum.ratio >= interactions[1] & area.df$area.intersection.sum.ratio <= interactions[2])){#
					# If conditions not met, try again from scratch. In future versions it would be useful to slide the polygons along their center axes to make minor adjustments.#
					next#
				}#
			}#
		}#
		### Method using st_sample from SF package. Probably not as useful as the spsample from SP.#
		if(FALSE){#
			### Convert each SpatialPolygons object to an SF object#
	#		sample.area.sf <- sf::st_as_sf(sample.area.sp)#
			grp.areas.sf <- lapply(X=1:n.grp,FUN=function(x){sf::st_as_sf(grp.areas.sp[[x]])})#
			### Sample within each area. If points must be over land, sample four times as many points as requested by 'size' argument.#
			if(over.land){#
				nsamp <- (grp.sizes*4)#
				samples.sf.temp  <- lapply(X=1:n.grp,FUN=function(x){sf::st_sample(x=grp.areas.sf[[x]], size= nsamp[x])})#
			} else {#
				samples.sf.temp  <- lapply(X=1:n.grp,FUN=function(x) {sf::st_sample(x= grp.areas.sf[[x]],size=grp.sizes[x])})#
			}#
			### Hold sampled coordinates as a list of data matrices#
			samples.mat.temp <- lapply(X=1:n.grp,FUN=function(x){sf::st_coordinates(samples.sf.temp[[x]])})#
		}#
		### Method using spsample from SP package.#
		if(over.land){#
			nsamp <- (grp.sizes*4)#
			samples.sp.temp  <- lapply(X=1:n.grp,FUN=function(x){sp::spsample(x=grp.areas.sp[[x]], n= nsamp[x], type="random")})#
		} else {#
			samples.sp.temp  <- lapply(X=1:n.grp,FUN=function(x) {sp::spsample(x= grp.areas.sp[[x]],n=grp.sizes[x], type="random")})#
		}#
		samples.mat.temp <- lapply(X=1:n.grp,FUN=function(x){sp::coordinates(samples.sp.temp[[x]])})#
		### Hold sampled coordinates as a list of data frames, and include a column in each data frame to indicate group assignment#
		samples.df.temp <- do.call(rbind,lapply(X=1:n.grp,FUN=function(x){data.frame(X=samples.mat.temp[[x]][,1],Y=samples.mat.temp[[x]][,2],group=x)}))#
		# Filtering samples outside of 'wnd'; 1=sample is within wnd; NA=sample is outside of wnd#
		samples.in.wnd <- unlist(lapply(1:n.grp,function(x) over(samples.sp.temp[[x]],wnd.sp)))#
		if(any(samples.in.wnd)==1){#
			samples.df.temp <- samples.df.temp[which(samples.in.wnd==1),]#
		}#
		### Hold sampled coordinates as a list of data frames, and include a column in each data frame to indicate group assignment#
#		samples.df.temp <- lapply(X=1:n.grp,FUN=function(x){data.frame(X=samples.mat.temp[[x]][,1],Y=samples.mat.temp[[x]][,2],group=x)})#
		####### PAUSED HERE ###########
		# ggplot2::ggplot(data = world.land) + ggplot2::geom_sf() + ggplot2::theme_classic() + ggplot2::geom_point(data = samples.df.temp, ggplot2::aes(x = X, y = Y), size = 2, shape = 21, fill = "darkred") # + coord_sf(xlim = c(-90, -78), ylim = c(24.5, 40), expand = FALSE)#
		if(over.land){#
			### Get subset of sampled coordinates that fall on land#
			#samples.temp <- lapply(X=1:n.grp,FUN=function(x){points.on.land(x=samples.mat.temp[[x]])})#
			# filtering samples that are not on land#
			samples.temp <- points.on.land(samples.df.temp)#
		#	samples.temp <- lapply(X=1:n.grp,FUN=function(x){points.on.land(x=samples.df.temp[[x]])})#
			#samples.land.temp <- points.on.land(x=samples.df.temp)#
		} else {#
			samples.temp           <- samples.df.temp#
			# colnames(samples.temp) <- c("longitude","latitude")#
		}#
		# Number of points sampled for each group after filtering points#
	#	n.grp.pass  <- table(samples.temp[,"group"])#
		n.grp.pass  <- sapply(X=1:n.grp, FUN=function(x) length(grep(x,samples.temp[,"group"])))#
		#n.grp.pass  <- sapply(samples.temp,nrow)#
		#sapply(n.grp.pass,funct)#
		if(all(n.grp.pass >= grp.sizes)){#
			PASS=TRUE#
		} else {#
			PASS=FALSE#
		}#
		# result.temp <- rbind(result.temp,samples.temp)#
	}
wnd.sp
plot(wnd.sp)
grp.scaler.start <- grp.scaler#
	#result.temp        <- data.frame(NULL)#
	PASS=FALSE#
	miter <- 100#
	ctr   <- 0
if(length(samplesize)==1){#
		if((n.grp*min.grp.size) > samplesize){#
			stop("Total sample size 'samplesize' must be greater than the number of groups 'n.grp' times minimum group size 'min.grp.size'.",call.=FALSE)#
		}#
	} else {#
		if(length(samplesize)!=n.grp){#
			stop("If 'samplesize' is a numerical vector, then it must have a length equal to the number of groups 'n.grp'.",call.=FALSE)#
		}#
	}
wnd <- Luzon.sp
if(is(wnd,"matrix")){#
			stop("not yet implemented")#
			### in the future, each row will describe the bounding box of a group#
		} else {#
			if(is(wnd,"SpatialPolygons")){#
				if(FALSE){#
					stop("not yet implemented")#
					### In the future, a spatial polygons object can be supplied#
					world.land.sp    <- rnaturalearth::ne_countries(scale=110, returnclass="sp")#
					ph.land10.sp     <- world.land10.sp[which(world.land10.sp[,"sovereignt"][[1]]=="Philippines"),]#
					ph.island.areas  <- sapply(X=1:length(ph.land10.sp@polygons[[1]]@Polygons),FUN=function(x){ph.land10.sp@polygons[[1]]@Polygons[[x]]@area})#
					Luzon.polygon    <- ph.land10.sp@polygons[[1]]@Polygons[[which(ph.island.areas == max(ph.island.areas))]]#
					Luzon.sp         <- sp::SpatialPolygons(list(sp::Polygons(list(Luzon.polygon),1)))#
					# Would set 'wnd' argument to Luzon.sp#
					wnd <- Luzon.sp#
					# wnd.sp is simply wnd#
				}#
				wnd.sp <- wnd#
				raster::crs(wnd.sp)  <- sp::CRS("EPSG:4326")#
				wnd.area             <- wnd.sp@polygons[[1]]@Polygons[[1]]@area#
				regionsize.dd0       <- (regionsize*wnd.area)#
				regionsize.dd        <- (regionsize.dd0*0.25)#
			} else {#
			if(is(wnd,"numeric")){#
				# rectangular SpatialPolygons object with extent formed by 'wnd' argument.#
				wnd.sp <- as(raster::extent(wnd), "SpatialPolygons")#
				# area of the region bounded by 'wnd', in decimal degrees#
				wnd.sp2 <- wnd.sp#
				#sp::proj4string(wnd.sp2) <- sp::CRS("+proj=longlat +datum=WGS84")#
				raster::crs(wnd.sp2) <- sp::CRS("EPSG:4326")#
				#wnd.area <- attributes(attributes(wnd.sp2)$polygons[[1]])$area#
				wnd.area <- wnd.sp2@polygons[[1]]@Polygons[[1]]@area#
				# area of region spanning all group sampling areas, in decimal degrees#
				regionsize.dd0 <- (regionsize*wnd.area)#
				regionsize.dd  <- (regionsize.dd0*0.25)#
			}#
		}#
	}
plot(wnd.sp)
!PASS
ctr <- ctr + 1#
		if(ctr > miter){#
			stop(paste("after",miter,"attemps, failed to find points that pass conditions. ctr=",ctr,"ctr2=",ctr2,"; grp.scaler=",grp.scaler))#
		}#
		#if(ctr %in% seq(from=10,to=miter,by=10)){#
		if(ctr>1){#
			grp.scaler <- (grp.scaler*0.95)#
		}#
		### Clear the data frame if too few points on land during previous attempt#
		#result.temp         <- data.frame(NULL)#
		initial <- FALSE#
		### Find group centers that pass conditions#
		ctr2 <- 0
!initial
ctr2 <- ctr2 + 1#
			if(ctr2 > (miter/10)){#
				break#
				# stop(paste("failed to initialize after",miter,"attemps. ctr=",ctr,"ctr2=",ctr2))#
			}#
			if(ctr2>1){#
				grp.scaler <- (grp.scaler*0.99)#
			}#
			# Random point within wnd.sp to determine subregion within which group centers will occur#
			center.sp <- sp::spsample(wnd.sp,n=1,type="random")#
			# Length two vector with "x" and "y" entries from sample.center, to pass to spCircle#
			center.xy <- c(sp::coordinates(center.sp)); names(center.xy) <- c("x","y")#
			# Create a circular polygon centered at sample center; in this case #
			# sample.area.sp <- sampSurf::spCircle(radius=sqrt((regionsize/pi)),centerPoint=center.xy)[[1]]#
			# regionsize2 <- (10^regionsize)#
			# regionsize2 <- regionsize.dd#
			#if(n.grp==1){#
			#regionsize.dd <- (regionsize.dd*grp.scaler*0.5)#
			#}#
			sample.area.sp <- sampSurf::spCircle(radius=sqrt((regionsize.dd/pi)), centerPoint=center.xy)[[1]]#
			#sample.area.sp.area <- attributes(attributes(attributes(sample.area.sp)$polygons[[1]])[[1]][[1]])$area
sp::spsample(wnd.sp,n=1,type="random")
plot(center.sp,add=T)
center.sp
proj4string(wnd.sp)
crs(wnd.sp)
CRS(wnd.sp)
sp::CRS(wnd.sp)
sp::CRS("EPSG:4326")
raster::crs(wnd.sp)  <- sp::CRS("EPSG:4326")
proj4string(wnd.sp)
wkt(wnd.sp)
CRS(wnd.sp)
class(wnd.sp)
center.sp <- sp::spsample(wnd.sp, n=1, type="random")#
			# Length two vector with "x" and "y" entries from sample.center, to pass to spCircle#
			center.xy <- c(sp::coordinates(center.sp)); names(center.xy) <- c("x","y")#
			# Create a circular polygon centered at sample center; in this case #
			# sample.area.sp <- sampSurf::spCircle(radius=sqrt((regionsize/pi)),centerPoint=center.xy)[[1]]#
			# regionsize2 <- (10^regionsize)#
			# regionsize2 <- regionsize.dd#
			#if(n.grp==1){#
			#regionsize.dd <- (regionsize.dd*grp.scaler*0.5)#
			#}#
			sample.area.sp <- sampSurf::spCircle(radius=sqrt((regionsize.dd/pi)), centerPoint=center.xy)[[1]]
plot(center.sp)
plot(wnd.sp)
plot(center.sp,add=T)
n.grp>1
grp.pts <- sp::spsample(sample.area.sp,n=n.grp,type="random")#
				# coordinates extracted from grp.pts#
				grp.pts.mat <- sp::coordinates(grp.pts)#
				colnames(grp.pts.mat) <- c("x","y")
grp.areas <- (regionsize.dd*(grp.area.weights/(sum(grp.area.weights)))*grp.scaler)#
				# create polygons centered at grp.pts, from which each groups points will be drawn. First need to determine group sizes...#
				grp.areas.sp <- lapply(X=1:n.grp, FUN=function(x){sampSurf::spCircle(radius=sqrt((grp.areas/pi))[x],centerPoint=c(grp.pts.mat[x,]))[[1]]})#
				# Distance between group centers. Not sure if this is necessary.
grp.center.dists0 <- geodist::geodist(grp.pts.mat,measure="geodesic")#
				grp.center.dists  <- grp.center.dists0[lower.tri(grp.center.dists0)]
grp.pts
grp.areas
grp.center.dists0
plot(grp.pts,add=T,col="red")
sample.area.sp
plot(sample.area.sp,add=T)
regionsize.dd        <- (regionsize.dd0)
regionsize.dd
center.sp <- sp::spsample(wnd.sp, n=1, type="random")#
			# Length two vector with "x" and "y" entries from sample.center, to pass to spCircle#
			center.xy <- c(sp::coordinates(center.sp)); names(center.xy) <- c("x","y")#
			# Create a circular polygon centered at sample center; in this case #
			# sample.area.sp <- sampSurf::spCircle(radius=sqrt((regionsize/pi)),centerPoint=center.xy)[[1]]#
			# regionsize2 <- (10^regionsize)#
			# regionsize2 <- regionsize.dd#
			#if(n.grp==1){#
			#regionsize.dd <- (regionsize.dd*grp.scaler*0.5)#
			#}#
			sample.area.sp <- sampSurf::spCircle(radius=sqrt((regionsize.dd/pi)), centerPoint=center.xy)[[1]]
plot(sample.area.sp,add=T)
if(n.grp>1){#
				# Sample group sampling-center locations from within sample.area.sp#
				grp.pts <- sp::spsample(sample.area.sp,n=n.grp,type="random")#
				# coordinates extracted from grp.pts#
				grp.pts.mat <- sp::coordinates(grp.pts)#
				colnames(grp.pts.mat) <- c("x","y")#
				grp.areas <- (regionsize.dd*(grp.area.weights/(sum(grp.area.weights)))*grp.scaler)#
				# create polygons centered at grp.pts, from which each groups points will be drawn. First need to determine group sizes...#
				grp.areas.sp <- lapply(X=1:n.grp, FUN=function(x){sampSurf::spCircle(radius=sqrt((grp.areas/pi))[x],centerPoint=c(grp.pts.mat[x,]))[[1]]})#
				# Distance between group centers. Not sure if this is necessary.#
				# geodist(grp.pts.mat,measure="geodesic")#
				grp.center.dists0 <- geodist::geodist(grp.pts.mat,measure="geodesic")#
				grp.center.dists  <- grp.center.dists0[lower.tri(grp.center.dists0)]#
				# check that each group centers occur over land, if over.land is true#
			} else {#
				grp.pts.mat  <- matrix(center.xy,nrow=1,dimnames=list(c(NULL),c("x","y")))#
				grp.areas.sp <- list(sample.area.sp)#
			}
if(over.land){#
				if(length(points.on.land(x=grp.pts.mat)[,1]) < n.grp){#
				#if(length(points.on.land(x=sp::coordinates(grp.pts))[,1]) < n.grp){#
					next#
				}#
			}
length(points.on.land(x=grp.pts.mat)[,1]) < n.grp
ctr2 <- ctr2 + 1#
			if(ctr2 > (miter/10)){#
				break#
				# stop(paste("failed to initialize after",miter,"attemps. ctr=",ctr,"ctr2=",ctr2))#
			}#
			if(ctr2>1){#
				grp.scaler <- (grp.scaler*0.99)#
			}#
			# Random point within wnd.sp to determine subregion within which group centers will occur#
			center.sp <- sp::spsample(wnd.sp, n=1, type="random")#
			# Length two vector with "x" and "y" entries from sample.center, to pass to spCircle#
			center.xy <- c(sp::coordinates(center.sp)); names(center.xy) <- c("x","y")#
			# Create a circular polygon centered at sample center; in this case #
			# sample.area.sp <- sampSurf::spCircle(radius=sqrt((regionsize/pi)),centerPoint=center.xy)[[1]]#
			# regionsize2 <- (10^regionsize)#
			# regionsize2 <- regionsize.dd#
			#if(n.grp==1){#
			#regionsize.dd <- (regionsize.dd*grp.scaler*0.5)#
			#}#
			sample.area.sp <- sampSurf::spCircle(radius=sqrt((regionsize.dd/pi)), centerPoint=center.xy)[[1]]#
			#sample.area.sp.area <- attributes(attributes(attributes(sample.area.sp)$polygons[[1]])[[1]][[1]])$area#
			# Check if entire sample.area.sp is within window defined by 'wnd' argument#
	#		area.wnd.diff <- rgeos::gDifference(spgeom1=sample.area.sp,spgeom2=wnd.sp)#
	#		# If area.wnd.diff is not NULL, then part of 'sample.area.sp' falls outside of the sampling window.#
	#		if(!is.null(area.wnd.diff)){#
	#			next#
	#		}#
			if(n.grp>1){#
				# Sample group sampling-center locations from within sample.area.sp#
				grp.pts <- sp::spsample(sample.area.sp,n=n.grp,type="random")#
				# coordinates extracted from grp.pts#
				grp.pts.mat <- sp::coordinates(grp.pts)#
				colnames(grp.pts.mat) <- c("x","y")#
				grp.areas <- (regionsize.dd*(grp.area.weights/(sum(grp.area.weights)))*grp.scaler)#
				# create polygons centered at grp.pts, from which each groups points will be drawn. First need to determine group sizes...#
				grp.areas.sp <- lapply(X=1:n.grp, FUN=function(x){sampSurf::spCircle(radius=sqrt((grp.areas/pi))[x],centerPoint=c(grp.pts.mat[x,]))[[1]]})#
				# Distance between group centers. Not sure if this is necessary.#
				# geodist(grp.pts.mat,measure="geodesic")#
				grp.center.dists0 <- geodist::geodist(grp.pts.mat,measure="geodesic")#
				grp.center.dists  <- grp.center.dists0[lower.tri(grp.center.dists0)]#
				# check that each group centers occur over land, if over.land is true#
			} else {#
				grp.pts.mat  <- matrix(center.xy,nrow=1,dimnames=list(c(NULL),c("x","y")))#
				grp.areas.sp <- list(sample.area.sp)#
			}
length(points.on.land(x=grp.pts.mat)[,1]) < n.grp
plot(grp.pts,add=T,col="blue")
plot(sample.area.sp,add=T,col="blue")
if(length(samplesize)==1){#
			if(n.grp==1){#
				grp.sizes <- samplesize#
			} else {#
				# Initial values for entering while loop#
				grp.sizes <- rep(0,n.grp)#
				while(any(grp.sizes < min.grp.size)){#
					grp.sizes  <- c(table(sample(x=c(1:n.grp),size=samplesize,prob=grp.n.weights,replace=TRUE)))#
					# verify that at least each group has at least min.grp.size.#
				}#
			}#
		} else {#
			grp.sizes <- samplesize#
		}
grp.sizes
!is.null(interactions) & n.grp > 1
!(interactions[1]==0 & interactions[2]==1)
polygons.list <- lapply(X=1:n.grp, function(x) grp.areas.sp[[x]]@polygons[[1]]@Polygons[[1]])#
				# All possible pairwise group comparisons#
				grp.pairs <- do.call(rbind,pset(1:n.grp,2,2))#
				# Calculate intersect area yet and sum areas for each pair of groups. (Doesnt work yet).#
				grp.int.area <- grp.sum.area <- grp.ratio <- c()
nrow(grp.pairs)
i=1
polygon.pair   <- polygons.list[c(grp.pairs[i,1],grp.pairs[i,2])]#
					grp1.area.temp <- polygon.pair[[1]]@area#
					grp2.area.temp <- polygon.pair[[2]]@area#
					pairsum.temp   <- sum(c(grp1.area.temp, grp2.area.temp))
grp.int  <- rgeos::gIntersection(spgeom1=grp.areas.sp[[grp.pairs[i,1]]],spgeom2=grp.areas.sp[[grp.pairs[i,2]]])#
					#Nonintersecting portions of areas 1 and 2 (faster than getting diff of each in the other and then adding)#
					#grp.diff <- rgeos::gSymdifference(spgeom1=grp.areas.sp[[grp.pairs[i,1]]],spgeom2=grp.areas.sp[[grp.pairs[i,2]]])#
					# returns a spatial polygons object with the non-intersecting portions of the group pair polygons each as their own polygons. If no overlap the returned polygons are the same the input polygons.#
					grp.diff1 <- rgeos::gDifference(spgeom1=grp.areas.sp[[grp.pairs[i,1]]],spgeom2=grp.areas.sp[[grp.pairs[i,2]]])#
					grp.diff2 <- rgeos::gDifference(spgeom1=grp.areas.sp[[grp.pairs[i,2]]],spgeom2=grp.areas.sp[[grp.pairs[i,1]]])#
					if(is.null(grp.int)){#
						int.area.temp <- 0#
					} else {#
						#int.area.temp <- attributes(attributes(attributes(grp.int)$"polygons"[[1]])[[1]][[1]])$area#
						int.area.temp <- grp.int@polygons[[1]]@Polygons[[1]]@area#
					}#
					# Area of the region of group 1 that does not intersect group 2 (for this pair of groups).#
					if(is.null(grp.diff1)){#
						diff1.area.temp <- 0#
					} else {#
						#diff1.area.temp <- attributes(attributes(attributes(grp.diff1)$"polygons"[[1]])[[1]][[1]])$area#
						diff1.area.temp <- grp.diff1@polygons[[1]]@Polygons[[1]]@area#
					}#
					if(is.null(grp.diff2)){#
						diff2.area.temp <- 0#
					} else {#
						#diff2.area.temp <- attributes(attributes(attributes(grp.diff2)$"polygons"[[1]])[[1]][[1]])$area#
						diff2.area.temp <- grp.diff2@polygons[[1]]@Polygons[[1]]@area#
					}
diff.area.temp  <- diff1.area.temp + diff2.area.temp#
					ratio.temp <- int.area.temp/diff.area.temp#
					#ratio.temp <- (int.area.temp/pairsum.temp)#
					#grp.int <- raster::intersect(spgeom1=sample.area.sp[[1]],spgeom2=sample.area.sp[[2]])#
					grp.int.area <- c(grp.int.area,int.area.temp)#
					grp.sum.area <- c(grp.sum.area,pairsum.temp)#
					grp.ratio    <- c(grp.ratio,ratio.temp)
area.df <- data.frame(group.i=grp.pairs[,1],group.j=grp.pairs[,2],area.intersection=grp.int.area,area.sumpair=grp.sum.area,area.intersection.sum.ratio=grp.ratio)
!all(area.df$area.intersection.sum.ratio >= interactions[1] & area.df$area.intersection.sum.ratio <= interactions[2])
nsamp <- (grp.sizes*4)
samples.sp.temp  <- lapply(X=1:n.grp,FUN=function(x){sp::spsample(x=grp.areas.sp[[x]], n= nsamp[x], type="random")})
samples.mat.temp <- lapply(X=1:n.grp,FUN=function(x){sp::coordinates(samples.sp.temp[[x]])})
samples.df.temp <- do.call(rbind,lapply(X=1:n.grp,FUN=function(x){data.frame(X=samples.mat.temp[[x]][,1],Y=samples.mat.temp[[x]][,2],group=x)}))
samples.in.wnd <- unlist(lapply(1:n.grp,function(x) over(samples.sp.temp[[x]],wnd.sp)))
CRS(wnd.sp)
class(wnd.sp)
CRS(samples.sp.temp)
identicalCRS(samples.sp.temp, wnd.sp)
proj4string(samples.sp.temp)
class(samples.sp.temp)
samples.sp.temp
identicalCRS(samples.sp.temp[[1]], wnd.sp)
identicalCRS(samples.sp.temp[[2]], wnd.sp)
identicalCRS(wnd.sp,wnd.sp)
CRS(wnd.sp)
sp::CRS(wnd.sp)
sp::CRS(list(wnd.sp))
plot(wnd.sp)
class(wnd.sp)
test <- <- as(raster::extent(c(-180,180,-90,90)), "SpatialPolygons")
test <- as(raster::extent(c(-180,180,-90,90)), "SpatialPolygons")
CRS(test)
raster::crs(test) <- sp::CRS("EPSG:4326")
CRS(test)
test
crs(test)
sp::crs(test)
raster::crs(test)
raster::crs(wnd.sp)
plot(samples.sp.temp[[1]],add=T)
raster::crs(samples.sp.temp)
raster::crs(samples.sp.temp) <- sp::CRS("EPSG:4326")
class(samples.sp.temp)
for(i in 1:length(samples.sp.temp)){#
				raster::crs(samples.sp.temp[[i]]) <- sp::CRS("EPSG:4326")#
			}
samples.mat.temp <- lapply(X=1:n.grp,FUN=function(x){sp::coordinates(samples.sp.temp[[x]])})#
		### Hold sampled coordinates as a list of data frames, and include a column in each data frame to indicate group assignment#
		samples.df.temp <- do.call(rbind,lapply(X=1:n.grp,FUN=function(x){data.frame(X=samples.mat.temp[[x]][,1],Y=samples.mat.temp[[x]][,2],group=x)}))
samples.in.wnd <- unlist(lapply(1:n.grp,function(x) over(samples.sp.temp[[x]],wnd.sp)))
if(any(samples.in.wnd)==1){#
			samples.df.temp <- samples.df.temp[which(samples.in.wnd==1),]#
		}
samples.temp <- points.on.land(samples.df.temp)
n.grp.pass  <- sapply(X=1:n.grp, FUN=function(x) length(grep(x,samples.temp[,"group"])))
all(n.grp.pass >= grp.sizes)
result <- samples.temp[unlist(lapply(1:n.grp,function(x) grep(x,samples.temp[,"group"])[1:grp.sizes[x]])),]
mode(result[,"group"]) <- "character"#
	# Convert data frame to spatial points object.#
	result.sp <- sp::SpatialPoints(result[,c(1,2)])#
	# Minimum convex hull polygon of all points.#
	mcp.sp         <- suppressWarnings(adehabitatHR::mcp(result.sp,percent=100))#
	#mcp.sp.area <- attributes(attributes(attributes(mcp.sp)$"polygons"[[1]])[[1]][[1]])$area#
	mcp.sp.area    <- mcp.sp@polygons[[1]]@Polygons[[1]]@area#
	absolute.areas <- c(windowarea=wnd.area,regionsize.dd0=regionsize.dd0,regionsize.dd=regionsize.dd,min.convex.hull.result=mcp.sp.area)#
	relative.areas <- round((absolute.areas/wnd.area),digits=4)#
	areas.df       <- data.frame(absolute =absolute.areas, relative.to.wnd=relative.areas)
world.land     <- rnaturalearth::ne_countries(scale=110, returnclass="sf")#
		world.land10   <- rnaturalearth::ne_countries(scale=10, returnclass="sf")#
		result.df2plot <- result#
		xdist <- geodist::geodist(result.df2plot[order(result.df2plot[,1]),][c(1,nrow(result.df2plot)),1:2],measure="geodesic",sequential=T)#
		ydist <- geodist::geodist(result.df2plot[order(result.df2plot[,2]),][c(1,nrow(result.df2plot)),1:2],measure="geodesic",sequential=T)#
		plot.margin <- which(c(xdist,ydist)==max(c(xdist,ydist)))#
		zoommaparea.km <- (xdist/1000)*(ydist/1000)#
		if(zoommaparea.km <10e6){#
			zoom.map <- world.land10#
		} else {#
			zoom.map <- world.land#
		}
spbb   <- sp::bbox(result.sp)#
		spbb2  <- apply(spbb,MARGIN=1,FUN=rangeBuffer,f=0.1)#
		dfbb   <- data.frame(x1=spbb[1,1], x2=spbb[1,2], y1=spbb[2,1], y2=spbb[2,2])#
		ggrect <- ggplot2::geom_rect(data=dfbb, mapping=ggplot2::aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2),fill="black",color="black",alpha=0.1)#
		zoom.plot   <- ggplot2::ggplot(data = zoom.map) + ggplot2::geom_sf() + ggplot2::theme_classic() + ggplot2::geom_point(data = result.df2plot, ggplot2::aes(x = X, y = Y, fill=group), size = 2, shape = 21) + ggplot2::coord_sf(xlim =range(result.df2plot[,1]),ylim = range(result.df2plot[,2])) + ggplot2::theme(panel.border = ggplot2::element_rect(color = "black", fill=NA, size=1)) + ggplot2::theme(legend.position = "none") + ggplot2::xlab("longitude") + ggplot2::ylab("latitude")#
		global.plot <- ggplot2::ggplot(data = world.land) + ggplot2::geom_sf() + ggplot2::theme_classic() + ggplot2::geom_point(data = result.df2plot, ggplot2::aes(x = X, y = Y, fill=group), size = 2, shape = 21) + ggplot2::theme(panel.border = ggplot2::element_rect(color = "black", fill=NA, size=1)) + ggplot2::theme(axis.title.y = ggplot2::element_blank(), axis.title.x = ggplot2::element_blank()) + ggrect
grobs.list <- list(ggplot2::ggplotGrob(global.plot),ggplot2::ggplotGrob(zoom.plot))#
		if(plot.margin==2){#
			bothmaps   <- gridExtra::arrangeGrob(grobs=grobs.list, layout_matrix=matrix(c(1,1,2),ncol=3))#
		} else {#
			bothmaps   <- gridExtra::arrangeGrob(grobs=grobs.list, layout_matrix=matrix(c(1,2),ncol=1))#
		}
grid::grid.newpage()#
		grid::grid.draw(bothmaps)
devtools::document()
test <- rcoords(regionsize=1,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=1,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=2,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=2,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=2,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
devtools::document()
test <- rcoords(regionsize=2,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=3,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=5,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=4,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
any(c(1,1,1)==1)
any(c(1,1,1))==1
devtools::document()
test <- rcoords(regionsize=5,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
any(samples.in.wnd == 1)
devtools::document()
test <- rcoords(regionsize=5,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test
any(samples.in.wnd == 1)
test <- rcoords(regionsize=5,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
any(samples.in.wnd == 1)
test <- rcoords(regionsize=5,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
any(samples.in.wnd == 1)
devtools::document()
test <- rcoords(regionsize=5,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=5,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=5,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=5,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=10,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=10,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test0 <- rep(NA,10)
any(test0==1)
any(test0)==1
any(test0==1,na.rm=T)
devtools::document()
test <- rcoords(regionsize=10,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=10,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=10,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=10,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
devtools::document()
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
sample.area.sp <- wnd.sp
grp.pts <- sp::spsample(sample.area.sp,n=2,type="random")
devtools::document()
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
devtools::document()
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP")
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(5,1))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(5,1),interactions=c(0,0.5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(10,1),interactions=c(0,0.5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(10,1),interactions=c(0,0.2))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(10,1),interactions=c(0,0.05))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0.05))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0))
test <- rcoords(regionsize=20,samplesize=100,n.grp=,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),grp.n.weights=c(20,1),interactions=c(0,0))
test <- rcoords(regionsize=20,samplesize=100,n.grp=,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,2),grp.n.weights=c(20,1),interactions=c(0,0))
test <- rcoords(regionsize=20,samplesize=100,n.grp=,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(1,1),grp.n.weights=c(20,1),interactions=c(0,0))
test <- rcoords(regionsize=20,samplesize=100,n.grp=,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),grp.n.weights=c(1,1),interactions=c(0,0))
test <- rcoords(regionsize=20,samplesize=100,n.grp=,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),grp.n.weights=NULL,interactions=c(0,0))
devtools::document()
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=NULL)
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=NULL)
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=c(10,5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=c(10,5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=c(10,5))
devtools::document()
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=c(10,5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=c(10,5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0.01,0.3),grp.n.weights=c(10,5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0.01,0.3),grp.n.weights=c(10,5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(30,1),interactions=c(0.01,0.1),grp.n.weights=c(10,5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(30,1),interactions=c(0,0.1),grp.n.weights=c(10,5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(30,1),interactions=c(0,0),grp.n.weights=c(10,5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(30,1),interactions=c(0,0),grp.n.weights=c(15,5))
test <- rcoords(regionsize=20,samplesize=100,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(30,1),interactions=c(0,0),grp.n.weights=c(30,1))
test <- rcoords(regionsize=20,samplesize=500,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(30,1),interactions=c(0,0),grp.n.weights=c(30,1))
test <- rcoords(regionsize=20,samplesize=500,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(30,1),interactions=c(0,0),grp.n.weights=c(30,1))
test <- rcoords(regionsize=20,samplesize=500,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=c(30,1))
test <- rcoords(regionsize=20,samplesize=500,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=c(30,1))
test <- rcoords(regionsize=20,samplesize=500,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=c(30,1))
test <- rcoords(regionsize=20,samplesize=500,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(20,1),interactions=c(0,0),grp.n.weights=c(30,1))
test <- rcoords(regionsize=20,samplesize=500,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(97453,12512),interactions=c(0,0),grp.n.weights=c(30,1))
test <- rcoords(regionsize=20,samplesize=500,n.grp=2,wnd=Luzon.sp,show.plot=T,return.as="SP",grp.area.weights=c(97453,12512),interactions=c(0,0),grp.n.weights=c(30,1))
q("no")
