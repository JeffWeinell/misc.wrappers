cfmodestum.qrates2.chain1 <- eemsgg2raster(gg.obj= cfmodestum.gg.chain1$qrates02,file.out="/Users/alyssaleinweber/Downloads/cfmodestum_mcmc/cfmodestum_chain1_qrates02.tif")
eemsgg2raster(gg.obj= cfmodestum.gg.chain2$mrates01,file.out="/Users/alyssaleinweber/Downloads/cfmodestum_mcmc/cfmodestum_chain2_mrates01.tif"); eemsgg2raster(gg.obj= cfmodestum.gg.chain2$mrates02,file.out="/Users/alyssaleinweber/Downloads/cfmodestum_mcmc/cfmodestum_chain2_mrates02.tif"); eemsgg2raster(gg.obj= cfmodestum.gg.chain2$qrates01,file.out="/Users/alyssaleinweber/Downloads/cfmodestum_mcmc/cfmodestum_chain2_qrates01.tif"); eemsgg2raster(gg.obj= cfmodestum.gg.chain2$qrates02,file.out="/Users/alyssaleinweber/Downloads/cfmodestum_mcmc/cfmodestum_chain2_qrates02.tif")
eemsgg2raster(gg.obj= cfmodestum.gg.chain3$mrates01,file.out="/Users/alyssaleinweber/Downloads/cfmodestum_mcmc/cfmodestum_chain3_mrates01.tif"); eemsgg2raster(gg.obj= cfmodestum.gg.chain3$mrates02,file.out="/Users/alyssaleinweber/Downloads/cfmodestum_mcmc/cfmodestum_chain3_mrates02.tif"); eemsgg2raster(gg.obj= cfmodestum.gg.chain3$qrates01,file.out="/Users/alyssaleinweber/Downloads/cfmodestum_mcmc/cfmodestum_chain3_qrates01.tif"); eemsgg2raster(gg.obj= cfmodestum.gg.chain3$qrates02,file.out="/Users/alyssaleinweber/Downloads/cfmodestum_mcmc/cfmodestum_chain3_qrates02.tif")
packageVersion("raster")
install.packages("raster")
rgdal::getGDALVersionInfo()
packageVersion("rgdal")
leporinum.gg.chain1 <- reemsplots2::make_eems_plots("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain1")
leporinum.gg.chain2 <- reemsplots2::make_eems_plots("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain2")
leporinum.gg.chain3 <- reemsplots2::make_eems_plots("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain3")
eemsgg2raster(gg.obj= leporinum.gg.chain1$mrates01,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain1_mrates01.tif")#
eemsgg2raster(gg.obj= leporinum.gg.chain1$mrates02,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain1_mrates02.tif")#
eemsgg2raster(gg.obj= leporinum.gg.chain1$qrates01,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain1_qrates01.tif")#
eemsgg2raster(gg.obj= leporinum.gg.chain1$qrates02,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain1_qrates02.tif")
eemsgg2raster(gg.obj= leporinum.gg.chain2$mrates01,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain2_mrates01.tif")#
eemsgg2raster(gg.obj= leporinum.gg.chain2$mrates02,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain2_mrates02.tif")#
eemsgg2raster(gg.obj= leporinum.gg.chain2$qrates01,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain2_qrates01.tif")#
eemsgg2raster(gg.obj= leporinum.gg.chain2$qrates02,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain2_qrates02.tif")
eemsgg2raster(gg.obj= leporinum.gg.chain3$mrates01,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain3_mrates01.tif")#
eemsgg2raster(gg.obj= leporinum.gg.chain3$mrates02,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain3_mrates02.tif")#
eemsgg2raster(gg.obj= leporinum.gg.chain3$qrates01,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain3_qrates01.tif")#
eemsgg2raster(gg.obj= leporinum.gg.chain3$qrates02,file.out="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain3_qrates02.tif")
gg.obj <- gg$mrates01
gg.obj <- leporinum.gg.chain1
gg.obj.mrates1 <- leporinum.gg.chain1$mrates01
gg.obj <- leporinum.gg.chain1
gg.data.mrates1 <- ggplot2::ggplot_build(gg.obj$mrates01)[[1]][[1]]
dim(gg.data.mrates1)
rgb.mat.mrates1 <- t(col2rgb(gg.data.mrates1$fill))
dim(rgb.mat.mrates1)
colnames(rgb.mat.mrates1)
paste0(c("red","green","blue"),".mrates1")
paste0(c("red","green","blue"),".m1")
gg.data.mrates2 <- ggplot2::ggplot_build(gg.obj$mrates02)[[1]][[1]]#
	gg.data.qrates1 <- ggplot2::ggplot_build(gg.obj$qrates01)[[1]][[1]]#
	gg.data.qrates2 <- ggplot2::ggplot_build(gg.obj$qrates02)[[1]][[1]]
rgb.mat.mrates1 <- t(col2rgb(gg.data.mrates1$fill))#
	rgb.mat.mrates2 <- t(col2rgb(gg.data.mrates2$fill))#
	rgb.mat.qrates1 <- t(col2rgb(gg.data.qrates1$fill))#
	rgb.mat.qrates2 <- t(col2rgb(gg.data.qrates2$fill))
colnames(rgb.mat.mrates1) <- paste0(c("red","green","blue"),".m1")#
	colnames(rgb.mat.mrates2) <- paste0(c("red","green","blue"),".m2")#
	colnames(rgb.mat.qrates1) <- paste0(c("red","green","blue"),".q1")#
	colnames(rgb.mat.qrates2) <- paste0(c("red","green","blue"),".q2")
rgb.mat.mrates2[1:2,]
df       <- cbind(gg.data.mrates1[,c("x","y")], rgb.mat.mrates1, rgb.mat.mrates2, rgb.mat.qrates1, rgb.mat.qrates2)
df[1:10,]
log10(1)
log10(10)
log10(50)
log10(60)
log10(100)
log10(1000)
log10(10000)
log10(500)
xcoords <- readLines("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain3/mcmcxcoord.txt")
ycoords <- readLines("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain3/mcmcycoord.txt")
wcoords <- readLines("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain3/mcmcwcoord.txt")
zcoords <- readLines("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain3/mcmczcoord.txt")
nrow(xcoords)
length(xcoords)
length(ycoords)
length(wcoords)
xcoords[1]
strsplit(xcoords[1],split=" ")
xcoord.path <- "/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain3/mcmcxcoord.txt"#
ycoord.path <- "/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain3/mcmcycoord.txt"#
wcoord.path <- "/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain3/mcmcwcoord.txt"#
zcoord.path <- "/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain3/mcmczcoord.txt"
xcoords <- lapply(readLines(xcoord.path),FUN=strsplit,split=" ")
xcoords[1]
xcoords <- unlist(lapply(readLines(xcoord.path),FUN=strsplit,split=" "))
length(xcoords)
xcoords[1]
xcoords <- as.numeric(unlist(lapply(readLines(xcoord.path),FUN=strsplit,split=" ")))
xccords[1]
xcoords[1]
xcoords[2]
ycoords <- as.numeric(unlist(lapply(readLines(ycoord.path),FUN=strsplit,split=" ")))#
wcoords <- as.numeric(unlist(lapply(readLines(wcoord.path),FUN=strsplit,split=" ")))#
zcoords <- as.numeric(unlist(lapply(readLines(zcoord.path),FUN=strsplit,split=" ")))
mcmcdir <- "/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain3/"
xcoord.path <- paste0(mcmcdir,"/mcmcxcoord.txt")
xcoord.path
xcoords <- as.numeric(unlist(lapply(readLines(xcoord.path),FUN=strsplit,split=" ")))
xcoords[1]
length(xcoords)
length(ycoords)
length(wcoords)
length(zcoords)
nrow(df)
53872-21592
53872-21592-15921
mcmcdir <- "/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain1/"#
# paths to coordinates of tiles#
xcoord.path <- paste0(mcmcdir,"/mcmcxcoord.txt")#
ycoord.path <- paste0(mcmcdir,"/mcmcycoord.txt")#
wcoord.path <- paste0(mcmcdir,"/mcmcwcoord.txt")#
zcoord.path <- paste0(mcmcdir,"/mcmczcoord.txt")#
# numerical vectors of tile coordinates #
xcoords <- as.numeric(unlist(lapply(readLines(xcoord.path),FUN=strsplit,split=" ")))#
ycoords <- as.numeric(unlist(lapply(readLines(ycoord.path),FUN=strsplit,split=" ")))#
wcoords <- as.numeric(unlist(lapply(readLines(wcoord.path),FUN=strsplit,split=" ")))#
zcoords <- as.numeric(unlist(lapply(readLines(zcoord.path),FUN=strsplit,split=" ")))
# path to mrates#
mrates.path <- paste0(mcmcdir,"/mcmcmrates.txt")#
# path to qrates#
qrates.path <- paste0(mcmcdir,"/mcmcqrates.txt")
mrates <- as.numeric(unlist(lapply(readLines(mrates.path),FUN=strsplit,split=" ")))
length(mrates)
length(xcoords)
qrates <- as.numeric(unlist(lapply(readLines(qrates.path),FUN=strsplit,split=" ")))
length(qrates)
length(wcoords)
m.df   <- cbind(xcoords,ycoords,mrates)
m.df[1:10,]
m.df   <- cbind("lon"=xcoords,"lat"=ycoords,mrates)
m.df[1:10,]
m.df   <- as.data.frame(cbind("lon"=xcoords,"lat"=ycoords,mrates))#
q.df   <- as.data.frame(cbind("lon"=wcoords,"lat"=zcoords,qrates))
m.df[1:10,]
sp::coordinates(m.df) <- ~ lon + lat
sp::coordinates(q.df) <- ~ lon + lat
sp::gridded(m.df)     <- TRUE
sp::gridded(q.df)     <- TRUE
class(m.df)
m.raster <- rasterize(m.df)
m.raster <- rasterize(m.df,fun=min)
r <- raster(ncols=36, nrows=18)#
n <- 1000#
set.seed(123)#
x <- runif(n) * 360 - 180#
y <- runif(n) * 180 - 90#
xy <- cbind(x, y)#
# get the (last) indices#
r0 <- rasterize(xy, r)#
# presence/absensce (NA) (is there a point or not?)#
r1 <- rasterize(xy, r, field=1)#
# how many points?#
r2 <- rasterize(xy, r, fun=function(x,...)length(x))#
vals <- runif(n)#
# sum of the values associated with the points#
r3 <- rasterize(xy, r, vals, fun=sum)
vals <- 1:n
length(vals)
vals[1:10]
p <- data.frame(xy, name=vals)
p[1:10,]
m.df[1:10,]
m.df   <- as.data.frame(cbind("lon"=xcoords,"lat"=ycoords,mrates))#
q.df   <- as.data.frame(cbind("lon"=wcoords,"lat"=zcoords,qrates))
m.df[1:10,]
m.df   <- as.data.frame(cbind("lon"=xcoords,"lat"=ycoords,mrates,"name"=1:length(mrates)))
m.df[1:10,]
coordinates(p) <- ~x+y
class(p)
class(r)
r <- rasterize(p, r, 'name', fun=min)
r2 <- rasterize(m.df,'name', fun=min)
sp::coordinates(m.df) <- ~ lon + lat
r2 <- rasterize(m.df,'name', fun=min)
r <- raster(ncols=36, nrows=18)
r2 <- rasterize(m.df,r,'name', fun=min)
128.236-120.288
min(m.df$lon)
max(m.df$lon)
min(m.df$lat)
max(m.df$lat)
max(m.df$lon)-min(m.df$lon)
(max(m.df$lon)-min(m.df$lon))*0.03204819
(max(m.df$lon)-min(m.df$lon))/0.03204819
m.df$lon
max(m.df$lon)
round(max(m.df$lon))
(round(max(m.df$lon))-round(min(m.df$lon)))/0.03204819
(max(m.df$lon)-min(m.df$lon))/0.03204819
min(m.df$lon)
round(min(m.df$lon))
(round(max(m.df$lon),digits=2)-round(min(m.df$lon),digits=2))/0.03204819
(round(max(m.df$lon),digits=1)-round(min(m.df$lon),digits=1))/0.03204819
(ceiling(max(m.df$lon))-ceiling(min(m.df$lon)))/0.03204819
test <- eemsgg2raster(gg.obj= modestum_chain1$mrates02)
class(test)
attributes(test)
summary(test)
test
test$resolution
names(test)
names(attributes(test))
(128.236-120.288)/0.03204819
(max(m.df$lon)-min(m.df$lon))/0.03204819
round((max(m.df$lon)-min(m.df$lon))/0.03204819)
ceiling((max(m.df$lon)-min(m.df$lon))/0.03204819)
m.rows <- ceiling((max(m.df$lon)-min(m.df$lon))/0.03204819)#
m.cols <- ceiling((max(m.df$lat)-min(m.df$lat))/0.03157018)#
q.rows <- ceiling((max(q.df$lon)-min(q.df$lon))/0.03204819)#
q.cols <- ceiling((max(q.df$lat)-min(q.df$lat))/0.03157018)
m.rows#
m.cols#
q.rows#
q.cols
min(c(m.df$lon,q.df$lon))
max(c(m.df$lon,q.df$lon))
m.raster <- raster(nrows=m.rows, ncols=m.cols)#
q.raster <- raster(nrows=q.rows, ncols=q.cols)
m.rasterized <- rasterize(m.df,m.raster)
q.rasterized <- rasterize(q.df,q.raster)
q.df   <- as.data.frame(cbind("lon"=wcoords,"lat"=zcoords,qrates))
sp::coordinates(q.df) <- ~ lon + lat
q.raster <- raster(nrows=q.rows, ncols=q.cols)
q.rasterized <- rasterize(q.df,q.raster)
raster::writeRaster(m.rasterized,filename="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain1_m.tif")
m.df   <- as.data.frame(cbind("lon"=xcoords,"lat"=ycoords,mrates))
m.df[1:10,]
max(m.df$mrates)
min(m.df$mrates)
m.df   <- as.data.frame(cbind("lon"=xcoords,"lat"=ycoords,mrates,logm=log10(mrates)))
m.df[1:10,]
max(m.df$logm)
min(m.df$logm)
q.df   <- as.data.frame(cbind("lon"=wcoords,"lat"=zcoords,qrates,logq=log10(qrates)))
sp::coordinates(m.df) <- ~ lon + lat#
sp::coordinates(q.df) <- ~ lon + lat#
# define an empty rasters with number of columns and rows determined by max and min coordinates#
m.rows <- ceiling((max(m.df$lon)-min(m.df$lon))/0.03204819)#
m.cols <- ceiling((max(m.df$lat)-min(m.df$lat))/0.03157018)#
q.rows <- ceiling((max(q.df$lon)-min(q.df$lon))/0.03204819)#
q.cols <- ceiling((max(q.df$lat)-min(q.df$lat))/0.03157018)#
m.raster <- raster(nrows=m.rows, ncols=m.cols)#
q.raster <- raster(nrows=q.rows, ncols=q.cols)#
# sp::gridded(m.df)     <- TRUE#
# sp::gridded(q.df)     <- TRUE#
m.rasterized <- rasterize(m.df,m.raster)#
q.rasterized <- rasterize(q.df,q.raster)
raster::writeRaster(m.rasterized,filename="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain1_m.tif")#
raster::writeRaster(q.rasterized,filename="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain1_q.tif")
raster::writeRaster(m.rasterized,filename="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain1_m.tif",overwrite=T)
?raster()
?raster()
?raster()
m.raster <- raster(xmn=floor(min(m.df$lon)),xmx=ceiling(max(m.df$lon)),ymn=floor(min(m.df$lat)),ymx=ceiling(max(m.df$lat)),resolution=c(0.03204819,0.03157018))
m.rasterized <- rasterize(m.df,m.raster)
m.rasterized
raster::writeRaster(m.rasterized,filename="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain1_m.tif")
m.rasterized <- rasterize(m.df,m.raster,fun=mean)
raster::writeRaster(m.rasterized,filename="/Users/alyssaleinweber/Downloads/leporinum_mcmc/leporinum_chain1_m.tif",overwrite=T)
library(deldir)
?read_matrix()
outer <- read.table("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain1/outer.txt")
ouet[1:2,]
outer[1:2,]
lines <- tolower(readLines(file.path(mcmcdir, "eemsrun.txt")))
length(lines)
lines[1]
lines[2]
lines
dist_metric <- gsub("\\s*distance\\s*=\\s*(\\w+)", "\\1", lines[6])
dist_metric
outer[, c(2, 1)]
demes <- read.table("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain1/demes.txt")
nrow(demes)
demes[1:10,]
edges <- read.table("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain1/edges.txt")
ipmap <- as.numeric(readLines("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain1/ipmap.txt"))
ipmap
xlim <- range(outer[, 1])#
  ylim <- range(outer[, 2])
xlim
ylim
aspect <- (diff(ylim) / diff(xlim)) / cos(mean(ylim) * pi / 180)
aspect
aspect <- abs(aspect)
nmrks=100
if (aspect > 1) {#
    nxmrks <- nmrks#
    nymrks <- round(nxmrks * aspect)#
  } else {#
    nymrks <- nmrks#
    nxmrks <- round(nymrks / aspect)#
  }
ncmrks
nxmrks
nymrks
xmrks <- seq(from = xlim[1], to = xlim[2], length = nxmrks)#
  ymrks <- seq(from = ylim[1], to = ylim[2], length = nymrks)
marks <- cbind(rep(xmrks, times = nymrks), rep(ymrks, each = nxmrks))
outer_poly <-sp::SpatialPolygons(list(Polygons(list(Polygon(outer, hole = FALSE)), "1")))
marks <- sp::SpatialPoints(marks)[outer_poly, ]
dim(marks)
class(marks)
marks <- marks@coords
class(outer)
outer <- as_data_frame(outer) %>% setNames(c("x", "y"))
ipmap <- data.frame(id = ipmap) %>% count(id)
data.frame(id = ipmap)
read_matrix <- function(file, ncol = 2) {#
	stopifnot(file.exists(file))#
	matrix(scan(file, what = numeric(), quiet = TRUE),#
				 ncol = ncol, byrow = TRUE)#
}
edges <- read_matrix("/Users/alyssaleinweber/Downloads/leporinum_mcmc/300Demes-chain1/edges.txt")
edges[1:10,]
read_voronoi <- function(mcmcpath, longlat, is_mrates) {#
	if (is_mrates) {#
		rates <- read_vector(file.path(mcmcpath, "mcmcmrates.txt"))#
		tiles <- read_vector(file.path(mcmcpath, "mcmcmtiles.txt"))#
		xseed <- read_vector(file.path(mcmcpath, "mcmcxcoord.txt"))#
		yseed <- read_vector(file.path(mcmcpath, "mcmcycoord.txt"))#
	} else {#
		rates <- read_vector(file.path(mcmcpath, "mcmcqrates.txt"))#
		tiles <- read_vector(file.path(mcmcpath, "mcmcqtiles.txt"))#
		xseed <- read_vector(file.path(mcmcpath, "mcmcwcoord.txt"))#
		yseed <- read_vector(file.path(mcmcpath, "mcmczcoord.txt"))#
	}#
	if (!longlat) {#
		tempi <- xseed#
		xseed <- yseed#
		yseed <- tempi#
	}#
	list(rates = log10(rates), tiles = tiles, xseed = xseed, yseed = yseed)#
}
check_mcmcpath_contents <- function(mcmcpath) {#
	for (path in mcmcpath) {#
		for (file in c("rdistJtDobsJ.txt", "rdistJtDhatJ.txt", "rdistoDemes.txt","mcmcmtiles.txt", "mcmcmrates.txt", "mcmcxcoord.txt","mcmcycoord.txt", "mcmcqtiles.txt", "mcmcqrates.txt","mcmcwcoord.txt", "mcmczcoord.txt", "mcmcpilogl.txt","outer.txt", "demes.txt", "edges.txt", "ipmap.txt","eemsrun.txt")) {#
			if (!file.exists(file.path(path, file)))#
				stop("Each EEMS output folder should include ", file)#
		}#
	}#
}#
read_vector <- function(file) {#
	stopifnot(file.exists(file))#
	scan(file, what = numeric(), quiet = TRUE)#
}#
read_matrix <- function(file, ncol = 2) {#
	stopifnot(file.exists(file))#
	matrix(scan(file, what = numeric(), quiet = TRUE),ncol = ncol, byrow = TRUE)#
}
veroni <- read_voronoi(mcmcpath=mcmcdir)
veroni <- read_voronoi(mcmcpath=mcmcdir,is_mrates=T)
veroni <- read_voronoi(mcmcpath=mcmcdir,is_mrates=T,longlat=F)
class(veroni)
veroni[[1]][1]
veroni[[1]][2]
class(veroni$tiles)
veroni$tiles[1]
# Get the distance metric from `eemsrun.txt`; use `euclidean` by default.#
get_dist_metric <- function(mcmcpath) {#
	dist_metric <- "euclidean"#
	lines <- tolower(readLines(file.path(mcmcpath, "eemsrun.txt")))#
	for (line in lines) {#
		if (grepl("\\s*distance\\s*=\\s*", line))#
			dist_metric <- gsub("\\s*distance\\s*=\\s*(\\w+)", "\\1", line)#
	}#
	if (dist_metric != "euclidean" && dist_metric != "greatcirc")#
		stop("eemsrun.txt should specify `euclidean` or `greatcirc` distance.")#
	dist_metric#
}
get_dist_metric(mcmcdir)
read_dimns <- function(mcmcpath, longlat, nmrks = 100) {#
	outer <- read_matrix(file.path(mcmcpath, "outer.txt"))#
	ipmap <- read_vector(file.path(mcmcpath, "ipmap.txt"))#
	demes <- read_matrix(file.path(mcmcpath, "demes.txt"))#
	edges <- read_matrix(file.path(mcmcpath, "edges.txt"))#
	dist_metric <- get_dist_metric(mcmcpath)#
	if (!longlat) {#
		outer <- outer[, c(2,1)]#
		demes <- demes[, c(2,1)]#
	}#
	xlim   <- range(outer[, 1])#
	ylim   <- range(outer[, 2])#
	aspect <- (diff(ylim) / diff(xlim)) / cos(mean(ylim) * pi / 180)#
	aspect <- abs(aspect)#
	if (aspect > 1) {#
		nxmrks <- nmrks#
		nymrks <- round(nxmrks * aspect)#
	} else {#
		nymrks <- nmrks#
		nxmrks <- round(nymrks / aspect)#
	}#
	# Construct a rectangular "raster" of equally spaced pixels/marks#
	xmrks <- seq(from = xlim[1], to = xlim[2], length = nxmrks)#
	ymrks <- seq(from = ylim[1], to = ylim[2], length = nymrks)#
	marks <- cbind(rep(xmrks, times = nymrks), rep(ymrks, each = nxmrks))#
	# Exclude pixels that fall outside the habitat outline#
	outer_poly <-sp::SpatialPolygons(list(Polygons(list(Polygon(outer, hole = FALSE)), "1")))#
	marks <- sp::SpatialPoints(marks)[outer_poly, ]#
	marks <- marks@coords#
	### set column names to x and y#
	outer <- as_data_frame(outer) %>% setNames(c("x", "y"))#
	### #
	ipmap <- data_frame(id = ipmap) %>% count(id)#
	### set column names to x and y#
	demes <- as_data_frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = row_number()) %>% left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	edges <- bind_cols(demes[edges[, 1], ] %>% select(x, y),demes[edges[, 2], ] %>% select(x, y)) %>% setNames(c("x", "y", "xend", "yend"))#
	list(marks = marks, nmrks = nrow(marks), xlim = xlim, ylim = ylim,outer = outer, demes = demes, edges = edges, dist_metric = dist_metric)#
}
dimns = read_dimns(mcmcpath=mcmcdir,longlat=F)
### Uses read_matrix, read_vector, get_dist_metric#
read_dimns <- function(mcmcpath, longlat, nmrks = 100) {#
	outer <- read_matrix(file.path(mcmcpath, "outer.txt"))#
	ipmap <- read_vector(file.path(mcmcpath, "ipmap.txt"))#
	demes <- read_matrix(file.path(mcmcpath, "demes.txt"))#
	edges <- read_matrix(file.path(mcmcpath, "edges.txt"))#
	dist_metric <- get_dist_metric(mcmcpath)#
	if (!longlat) {#
		outer <- outer[, c(2,1)]#
		demes <- demes[, c(2,1)]#
	}#
	xlim   <- range(outer[, 1])#
	ylim   <- range(outer[, 2])#
	aspect <- (diff(ylim) / diff(xlim)) / cos(mean(ylim) * pi / 180)#
	aspect <- abs(aspect)#
	if (aspect > 1) {#
		nxmrks <- nmrks#
		nymrks <- round(nxmrks * aspect)#
	} else {#
		nymrks <- nmrks#
		nxmrks <- round(nymrks / aspect)#
	}#
	# Construct a rectangular "raster" of equally spaced pixels/marks#
	xmrks <- seq(from = xlim[1], to = xlim[2], length = nxmrks)#
	ymrks <- seq(from = ylim[1], to = ylim[2], length = nymrks)#
	marks <- cbind(rep(xmrks, times = nymrks), rep(ymrks, each = nxmrks))#
	# Exclude pixels that fall outside the habitat outline#
	outer_poly <-sp::SpatialPolygons(list(Polygons(list(Polygon(outer, hole = FALSE)), "1")))#
	marks <- sp::SpatialPoints(marks)[outer_poly, ]#
	marks <- marks@coords#
	### set column names to x and y#
	# outer <- as_data_frame(outer) %>% setNames(c("x", "y"))#
	outer <- as.data.frame(outer) %>% setNames(c("x", "y"))#
	### #
	### ipmap <- data_frame(id = ipmap) %>% count(id)#
	ipmap <- data.frame(id = ipmap) %>% count(id)#
	### set column names to x and y#
	# demes <- as_data_frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = row_number()) %>% left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	demes <- as.data.frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = row_number()) %>% left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	edges <- bind_cols(demes[edges[, 1], ] %>% select(x, y),demes[edges[, 2], ] %>% select(x, y)) %>% setNames(c("x", "y", "xend", "yend"))#
	list(marks = marks, nmrks = nrow(marks), xlim = xlim, ylim = ylim,outer = outer, demes = demes, edges = edges, dist_metric = dist_metric)#
}
dimns = read_dimns(mcmcpath=mcmcdir,longlat=F)
### Uses read_matrix, read_vector, get_dist_metric#
read_dimns <- function(mcmcpath, longlat, nmrks = 100) {#
	outer <- read_matrix(file.path(mcmcpath, "outer.txt"))#
	ipmap <- read_vector(file.path(mcmcpath, "ipmap.txt"))#
	demes <- read_matrix(file.path(mcmcpath, "demes.txt"))#
	edges <- read_matrix(file.path(mcmcpath, "edges.txt"))#
	dist_metric <- get_dist_metric(mcmcpath)#
	if (!longlat) {#
		outer <- outer[, c(2,1)]#
		demes <- demes[, c(2,1)]#
	}#
	xlim   <- range(outer[, 1])#
	ylim   <- range(outer[, 2])#
	aspect <- (diff(ylim) / diff(xlim)) / cos(mean(ylim) * pi / 180)#
	aspect <- abs(aspect)#
	if (aspect > 1) {#
		nxmrks <- nmrks#
		nymrks <- round(nxmrks * aspect)#
	} else {#
		nymrks <- nmrks#
		nxmrks <- round(nymrks / aspect)#
	}#
	# Construct a rectangular "raster" of equally spaced pixels/marks#
	xmrks <- seq(from = xlim[1], to = xlim[2], length = nxmrks)#
	ymrks <- seq(from = ylim[1], to = ylim[2], length = nymrks)#
	marks <- cbind(rep(xmrks, times = nymrks), rep(ymrks, each = nxmrks))#
	# Exclude pixels that fall outside the habitat outline#
	outer_poly <-sp::SpatialPolygons(list(Polygons(list(Polygon(outer, hole = FALSE)), "1")))#
	marks <- sp::SpatialPoints(marks)[outer_poly, ]#
	marks <- marks@coords#
	### set column names to x and y#
	# outer <- as_data_frame(outer) %>% setNames(c("x", "y"))#
	outer <- as.data.frame(outer) %>% setNames(c("x", "y"))#
	### #
	### ipmap <- data_frame(id = ipmap) %>% count(id)#
	ipmap <- data.frame(id = ipmap) %>% plyr::count(id)#
	### set column names to x and y#
	# demes <- as_data_frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = row_number()) %>% left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	demes <- as.data.frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = row_number()) %>% left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	edges <- bind_cols(demes[edges[, 1], ] %>% select(x, y),demes[edges[, 2], ] %>% select(x, y)) %>% setNames(c("x", "y", "xend", "yend"))#
	list(marks = marks, nmrks = nrow(marks), xlim = xlim, ylim = ylim,outer = outer, demes = demes, edges = edges, dist_metric = dist_metric)#
}
dimns = read_dimns(mcmcpath=mcmcdir,longlat=F)
library(plyr)
read_dimns <- function(mcmcpath, longlat, nmrks = 100) {#
	outer <- read_matrix(file.path(mcmcpath, "outer.txt"))#
	ipmap <- read_vector(file.path(mcmcpath, "ipmap.txt"))#
	demes <- read_matrix(file.path(mcmcpath, "demes.txt"))#
	edges <- read_matrix(file.path(mcmcpath, "edges.txt"))#
	dist_metric <- get_dist_metric(mcmcpath)#
	if (!longlat) {#
		outer <- outer[, c(2,1)]#
		demes <- demes[, c(2,1)]#
	}#
	xlim   <- range(outer[, 1])#
	ylim   <- range(outer[, 2])#
	aspect <- (diff(ylim) / diff(xlim)) / cos(mean(ylim) * pi / 180)#
	aspect <- abs(aspect)#
	if (aspect > 1) {#
		nxmrks <- nmrks#
		nymrks <- round(nxmrks * aspect)#
	} else {#
		nymrks <- nmrks#
		nxmrks <- round(nymrks / aspect)#
	}#
	# Construct a rectangular "raster" of equally spaced pixels/marks#
	xmrks <- seq(from = xlim[1], to = xlim[2], length = nxmrks)#
	ymrks <- seq(from = ylim[1], to = ylim[2], length = nymrks)#
	marks <- cbind(rep(xmrks, times = nymrks), rep(ymrks, each = nxmrks))#
	# Exclude pixels that fall outside the habitat outline#
	outer_poly <-sp::SpatialPolygons(list(Polygons(list(Polygon(outer, hole = FALSE)), "1")))#
	marks <- sp::SpatialPoints(marks)[outer_poly, ]#
	marks <- marks@coords#
	### set column names to x and y#
	# outer <- as_data_frame(outer) %>% setNames(c("x", "y"))#
	outer <- as.data.frame(outer) %>% setNames(c("x", "y"))#
	### #
	### ipmap <- data_frame(id = ipmap) %>% count(id)#
	ipmap <- plyr::count(data.frame(id = ipmap),vars="id")#
	### set column names to x and y#
	# demes <- as_data_frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = row_number()) %>% left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	demes <- as.data.frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = row_number()) %>% left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	edges <- bind_cols(demes[edges[, 1], ] %>% select(x, y),demes[edges[, 2], ] %>% select(x, y)) %>% setNames(c("x", "y", "xend", "yend"))#
	list(marks = marks, nmrks = nrow(marks), xlim = xlim, ylim = ylim,outer = outer, demes = demes, edges = edges, dist_metric = dist_metric)#
}
dimns = read_dimns(mcmcpath=mcmcdir,longlat=F)
read_dimns <- function(mcmcpath, longlat, nmrks = 100) {#
	outer <- read_matrix(file.path(mcmcpath, "outer.txt"))#
	ipmap <- read_vector(file.path(mcmcpath, "ipmap.txt"))#
	demes <- read_matrix(file.path(mcmcpath, "demes.txt"))#
	edges <- read_matrix(file.path(mcmcpath, "edges.txt"))#
	dist_metric <- get_dist_metric(mcmcpath)#
	if (!longlat) {#
		outer <- outer[, c(2,1)]#
		demes <- demes[, c(2,1)]#
	}#
	xlim   <- range(outer[, 1])#
	ylim   <- range(outer[, 2])#
	aspect <- (diff(ylim) / diff(xlim)) / cos(mean(ylim) * pi / 180)#
	aspect <- abs(aspect)#
	if (aspect > 1) {#
		nxmrks <- nmrks#
		nymrks <- round(nxmrks * aspect)#
	} else {#
		nymrks <- nmrks#
		nxmrks <- round(nymrks / aspect)#
	}#
	# Construct a rectangular "raster" of equally spaced pixels/marks#
	xmrks <- seq(from = xlim[1], to = xlim[2], length = nxmrks)#
	ymrks <- seq(from = ylim[1], to = ylim[2], length = nymrks)#
	marks <- cbind(rep(xmrks, times = nymrks), rep(ymrks, each = nxmrks))#
	# Exclude pixels that fall outside the habitat outline#
	outer_poly <-sp::SpatialPolygons(list(Polygons(list(Polygon(outer, hole = FALSE)), "1")))#
	marks <- sp::SpatialPoints(marks)[outer_poly, ]#
	marks <- marks@coords#
	### set column names to x and y#
	# outer <- as_data_frame(outer) %>% setNames(c("x", "y"))#
	outer <- as.data.frame(outer) %>% setNames(c("x", "y"))#
	### #
	### ipmap <- data_frame(id = ipmap) %>% count(id)#
	ipmap <- plyr::count(data.frame(id = ipmap),vars="id")#
	### set column names to x and y#
	# demes <- as_data_frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = row_number()) %>% left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	demes <- as.data.frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = row_number()) %>% dplyr::left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	edges <- bind_cols(demes[edges[, 1], ] %>% select(x, y),demes[edges[, 2], ] %>% select(x, y)) %>% setNames(c("x", "y", "xend", "yend"))#
	list(marks = marks, nmrks = nrow(marks), xlim = xlim, ylim = ylim,outer = outer, demes = demes, edges = edges, dist_metric = dist_metric)#
}
dimns = read_dimns(mcmcpath=mcmcdir,longlat=F)
read_dimns <- function(mcmcpath, longlat, nmrks = 100) {#
	outer <- read_matrix(file.path(mcmcpath, "outer.txt"))#
	ipmap <- read_vector(file.path(mcmcpath, "ipmap.txt"))#
	demes <- read_matrix(file.path(mcmcpath, "demes.txt"))#
	edges <- read_matrix(file.path(mcmcpath, "edges.txt"))#
	dist_metric <- get_dist_metric(mcmcpath)#
	if (!longlat) {#
		outer <- outer[, c(2,1)]#
		demes <- demes[, c(2,1)]#
	}#
	xlim   <- range(outer[, 1])#
	ylim   <- range(outer[, 2])#
	aspect <- (diff(ylim) / diff(xlim)) / cos(mean(ylim) * pi / 180)#
	aspect <- abs(aspect)#
	if (aspect > 1) {#
		nxmrks <- nmrks#
		nymrks <- round(nxmrks * aspect)#
	} else {#
		nymrks <- nmrks#
		nxmrks <- round(nymrks / aspect)#
	}#
	# Construct a rectangular "raster" of equally spaced pixels/marks#
	xmrks <- seq(from = xlim[1], to = xlim[2], length = nxmrks)#
	ymrks <- seq(from = ylim[1], to = ylim[2], length = nymrks)#
	marks <- cbind(rep(xmrks, times = nymrks), rep(ymrks, each = nxmrks))#
	# Exclude pixels that fall outside the habitat outline#
	outer_poly <-sp::SpatialPolygons(list(Polygons(list(Polygon(outer, hole = FALSE)), "1")))#
	marks <- sp::SpatialPoints(marks)[outer_poly, ]#
	marks <- marks@coords#
	### set column names to x and y#
	# outer <- as_data_frame(outer) %>% setNames(c("x", "y"))#
	outer <- as.data.frame(outer) %>% setNames(c("x", "y"))#
	### #
	### ipmap <- data_frame(id = ipmap) %>% count(id)#
	ipmap <- plyr::count(data.frame(id = ipmap),vars="id")#
	### set column names to x and y#
	# demes <- as_data_frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = row_number()) %>% left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	demes <- as.data.frame(demes) %>% setNames(c("x", "y")) %>% mutate(id = dplyr::row_number()) %>% dplyr::left_join(ipmap) %>% arrange(id) %>% mutate(n = if_else(is.na(n), 0L, n))#
	edges <- bind_cols(demes[edges[, 1], ] %>% select(x, y),demes[edges[, 2], ] %>% select(x, y)) %>% setNames(c("x", "y", "xend", "yend"))#
	list(marks = marks, nmrks = nrow(marks), xlim = xlim, ylim = ylim,outer = outer, demes = demes, edges = edges, dist_metric = dist_metric)#
}
dimns = read_dimns(mcmcpath=mcmcdir,longlat=F)
test <- c("#994000", "#CC5800", "#FF8F33", "#FFAD66", "#FFCA99", "#FFE6CC","#FBFBFB","#CCFDFF", "#99F8FF", "#66F0FF", "#33E4FF", "#00AACC", "#007A99")
is_color <- function(x) {#
	if(is.null(x)){#
		return(FALSE)#
	} else {#
		sapply(x, function(x){tryCatch(is.matrix(col2rgb(x)), error = function(e) FALSE)})#
	}#
}
is_color(test)
?dplyr::count
?setNames()
?seq_len
