i
for(i in 2:nrow(crossentropy.mat)){#
		t.test.i <- t.test(crossentropy.mat[i-1,],crossentropy.mat[i,])#
		pval.i   <- t.test.i$p.value#
		stat.i   <- t.test.i$statistic#
		if(pval.i < 0.05 & stat.i > 0){#
			next#
		} else {#
			if(i==nrow(crossentropy.mat)){#
				Kbest.criteria4 <- NULL#
			} else{#
				Kbest.criteria4 <- (i-1)#
				break#
			}#
		}#
	}
i
Kbest.criteria4
segments(x0=bestK,y0=par("usr")[3],y1=par("usr")[4],lty=2,col="black")
run_SNMF <- function(vcf,coords=NULL,Krange=1:40,reps=100,entropy=TRUE,project="new",iter=500,CPU=2,save.as=NULL){#
	vcf.obj     <- vcfR::read.vcfR(vcf)#
	samplenames <- colnames(vcf.obj@gt)[-1]#
	numind      <- length(samplenames)#
	label.size  <- min((288/numind),7)#
	if(!is.null(coords)){#
		if(is(coords,"array") | is(coords,"data.frame")){#
			coords <-  coords#
		} else {#
			if(file.exists(coords)){#
				coords   <- read.table(coords)#
			}#
		}#
		### Check that all individuals with coords are in the vcf file, and vice versa.#
		if(!all(samplenames %in% rownames(coords) & rownames(coords) %in% samplenames)){#
			stop("All individuals in coords file must be in vcf")#
		}#
		x.min <- min((coords[,1]-0.5))#
		x.max <- max((coords[,1]+0.5))#
		y.min <- min((coords[,2]-0.5))#
		y.max <- max((coords[,2]+0.5))#
		maxK <- min(nrow(unique(coords)),(numind-1))#
	} else {#
		maxK <- (numind-1)#
	}#
	if(max(Krange) > maxK){#
		Krange <- 1:maxK#
	}#
	geno.temp.path <- paste0(tempfile(),".geno")#
	geno.obj       <- vcfR2geno(vcf=vcf,out=geno.temp.path)#
	snmf.obj       <- LEA::snmf(geno.temp.path,K=Krange, repetitions=reps,entropy=entropy,project="new",iterations=iter,CPU=CPU)#
	crossentropy.mat  <- t(do.call(cbind,lapply(X=Krange,FUN=function(x){LEA::cross.entropy(snmf.obj,K = x)})))#
	rownames(crossentropy.mat) <- Krange#
	colnames(crossentropy.mat) <- paste0("rep",1:reps)#
	boxplot(t(crossentropy.mat))#
	mean.entropy   <- apply(crossentropy.mat,MARGIN=1,FUN=mean,na.rm=TRUE)#
#	plot(Krange,mean.entropy,pch=21,col="blue",xlab="",ylab="",xlim=range(Krange), ylim=range(range.entropy.mat))#
#	arrows(x0=Krange,y0=range.entropy.mat[,1],y1=range.entropy.mat[,2],length=0.07,col="black",angle=90,code=3)#
#	lines(Krange,mean.entropy,col="blue")#
	if(any(diff(mean.entropy)>0)){#
		bestK <- unname(which(diff(mean.entropy)>0)[1])#
	} else {#
		bestK <- unname(Krange[1])#
	}#
	Kbest.criteria1   <- bestK#
	### Checking if the max BIC of the next K value is less than the min BIC of the previous K value.#
	range.entropy.mat <- do.call(rbind,lapply(X=1:nrow(crossentropy.mat),FUN=function(x){range(crossentropy.mat[x,],na.rm=TRUE)}))#
	entropy.is.nonoverlap <- NULL#
	entropy.is.reduced    <- NULL#
	for(i in 2:nrow(range.entropy.mat)){#
		entropy.is.nonoverlap  <- c(entropy.is.nonoverlap, range.entropy.mat[i,1] > range.entropy.mat[(i-1),2] | range.entropy.mat[i,2] < range.entropy.mat[(i-1),1])#
		entropy.is.reduced     <- c(entropy.is.reduced, range.entropy.mat[i,2] < range.entropy.mat[(i-1),1])#
	}#
	# If max BIC for K=2 is better than BIC K=1 and if some K values are not better (all BIC lower) than K-1, then find the first K value in which K+1 is not better.#
	if(any(!entropy.is.reduced) & entropy.is.reduced[1]){#
		Kbest.criteria2 <- which(!entropy.is.reduced)[1]#
	} else {#
		Kbest.criteria2 <- 1#
	}#
	### Which K value (for K>=2) yields the least variable BIC scores.#
	Entropy.variation <- apply(X=crossentropy.mat,MARGIN=1,FUN=var,na.rm=TRUE)#
	Kbest.criteria3   <- which(Entropy.variation==min(Entropy.variation[-1]))#
	### Criteria 4: t-tests for entropy of each pairwise adjacent K#
	for(i in 2:nrow(crossentropy.mat)){#
		t.test.i <- t.test(crossentropy.mat[i-1,],crossentropy.mat[i,])#
		pval.i   <- t.test.i$p.value#
		stat.i   <- t.test.i$statistic#
		if(pval.i < 0.05 & stat.i > 0){#
			next#
		} else {#
			if(i==nrow(crossentropy.mat)){#
				Kbest.criteria4 <- NULL#
			} else{#
				Kbest.criteria4 <- (i-1)#
				break#
			}#
		}#
	}#
	segments(x0=bestK,y0=par("usr")[3],y1=par("usr")[4],lty=2,col="black")#
	# segments(x0=bestK,y0=par("usr")[3],y1=par("usr")[4],lty=2,col="green")#
	# segments(x0=Kbest.criteria2,y0=par("usr")[3],y1=par("usr")[4],lty=2,col="blue")#
	# segments(x0=Kbest.criteria3,y0=par("usr")[3],y1=par("usr")[4],lty=2,col="red")#
	mtext(side=1,"Number of ancestral populations",line=2.2)#
	mtext(side=2,"Cross-entropy",line=2.2)#
	mtext(side=3,paste0("Cross-entropy (",reps," replicates) vs. number of ancestral populations (K)"),line=1)#
	axis(1,at=Krange)#
	entropyPlot    <- recordPlot()#
	Krange.plot    <- setdiff(Krange,1)#
	admixturePlot  <- list(); length(admixturePlot)   <- length(Krange.plot)#
	mapplot        <- list(); length(mapplot)         <- length(Krange.plot)#
	for(K in Krange.plot){#
		i=(K-1)#
		ce           <- LEA::cross.entropy(snmf.obj, K = K)#
		best         <- which.min(ce)#
	#	q.matrix.best <- suppressWarnings(tess3r::as.qmatrix(LEA::Q(snmf.obj,K=bestK,run=best)))#
		if(K < 5){#
			myCols          <- goodcolors(K,thresh=100)#
		}#
		if(K >= 5 & K < 7){#
			myCols          <- goodcolors(K,thresh=100,cbspace="deut")#
		}#
		if(K >= 7 & K < 15){#
			myCols          <- goodcolors(K,thresh=100,cbspace="")#
		}#
		if(K>=15){#
			myCols          <- c(goodcolors(14,thresh=100,cbspace=""), sample(adegenet::funky(100), size=K-14))#
		}#
		q.matrix           <- LEA::Q(snmf.obj,K=K,run=best)#
		rownames(q.matrix) <- samplenames#
		colnames(q.matrix) <- paste0("cluster",1:ncol(q.matrix))#
		posterior.df       <- data.frame(indv=rep(rownames(q.matrix),ncol(q.matrix)), pop=rep(colnames(q.matrix),each=nrow(q.matrix)), assignment=c(unlist(unname(q.matrix))))#
		posterior.gg       <- ggplot2::ggplot(posterior.df, aes(fill= pop, x= assignment, y=indv)) + geom_bar(position="stack", stat="identity") + theme_classic() + theme(axis.text.y = element_text(size = label.size), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank()) + ggplot2::labs(x = "Membership Probability",y="",fill="Cluster",title=paste0("K = ",K)) + scale_fill_manual(values=myCols[1:K])#
		plot(posterior.gg)#
		admixturePlot[[i]]   <- recordPlot()#
		if(!is.null(coords)){#
			my.palette      <- tess3r::CreatePalette(myCols, 9)#
			xdist           <- geosphere::distm(x=c(x.min,0),y=c(x.max,0))#
			ydist           <- geosphere::distm(x=c(0,y.min),y=c(0,y.max))#
			mapplot.initial <- plot(suppressWarnings(tess3r::as.qmatrix(q.matrix)), as.matrix(coords), method = "map.max", interpol = FieldsKrigModel(10), main = paste0("Ancestry coefficients; K=",K), xlab = "", ylab = "",resolution = c(100,100), cex = 0.4,col.palette = my.palette, window=c(x.min,x.max,y.min,y.max),asp=xdist/ydist)#
			mapplot.i       <- plot(suppressWarnings(tess3r::as.qmatrix(q.matrix)), as.matrix(coords), method = "map.max", interpol = FieldsKrigModel(10), main = paste0("Ancestry coefficients; K=",K), xlab = "", ylab = "",resolution = c(500,500), cex = 0.4,col.palette = my.palette, window=c(par("usr")[1],par("usr")[2],par("usr")[3],par("usr")[4]),asp=xdist/ydist)#
			mapplot[[i]]    <- recordPlot()#
		}#
	}#
	if(!is.null(coords)){#
		result <- c(list(entropyPlot),admixturePlot,mapplot)#
	} else {#
		result <- c(list(entropyPlot),admixturePlot)#
	}#
	if(!is.null(save.as)){#
		pdf(height=6,width=10,file=save.as,onefile=TRUE)#
		lapply(X=result,FUN=print)#
		dev.off()#
	}#
	result#
}
bothmodestum <- run_SNMF(vcf="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/Oxyrhabdium_both-modestum_BestSNP.vcf",#
	                           coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/tess3r/Oxyrhabdium_bothmodestum_coords.txt",reps=30,Krange=1:4,#
	                           save.as="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/LEA/Oxyrhabdium_both-modestum_BestSNP_sNMF_run1.pdf")
bothmodestum <- run_SNMF(vcf="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/Oxyrhabdium_both-modestum_BestSNP.vcf",#
	                           coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/tess3r/Oxyrhabdium_bothmodestum_coords.txt",reps=30,Krange=1:4,#
	                           save.as="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/LEA/Oxyrhabdium_both-modestum_BestSNP_sNMF_test.pdf")
runtess <- function(vcf,coords=NULL,Krange=1:40,ploidy=2,mask=0.05,reps=100,max.iteration=500,save.as=NULL){#
	vcf.obj     <- vcfR::read.vcfR(vcf)#
	samplenames <- colnames(vcf.obj@gt)[-1]#
	numind      <- length(samplenames)#
	label.size  <- min((288/numind),7)#
	lfmm.obj    <- vcfR2lfmm(vcf=vcf)#
	if(is(coords,"array") | is(coords,"data.frame")){#
		coords <-  coords#
	} else {#
		if(file.exists(coords)){#
			coords   <- read.table(coords)#
		}#
	}#
	maxK <- min(nrow(unique(coords)),(numind-1))#
	if(max(Krange) > maxK){#
		Krange <- 1:maxK#
	}#
	tess.obj <- tess3r::tess3(X = lfmm.obj, coord = as.matrix(coords), K=Krange, ploidy = ploidy, verbose=FALSE ,mask=0.05, rep=reps, max.iteration=max.iteration,keep="all")#
	crossentropy.mat <- do.call(rbind,lapply(X=1:length(tess.obj),FUN=function(x){matrix(unlist(tess.obj[[x]]["crossentropy"]),nrow=1)}))#
	rownames(crossentropy.mat) <- Krange#
	colnames(crossentropy.mat) <- paste0("rep",1:reps)#
	par(mfrow=c(1,1))#
	mean.entropy <- apply(crossentropy.mat,MARGIN=1,FUN=mean,na.rm=TRUE)#
	range.entropy.mat <- do.call(rbind,lapply(X=1:nrow(crossentropy.mat),FUN=function(x){range(crossentropy.mat[x,],na.rm=TRUE)}))#
	boxplot(t(crossentropy.mat))#
	if(any(diff(mean.entropy)>0)){#
		bestK <- unname(which(diff(mean.entropy)>0)[1])#
	} else {#
		bestK <- unname(Krange[1])#
	}#
	### Criteria 3: Which K value (for K>=2) yields the least variable entropy scores.#
	Entropy.variation <- apply(X=crossentropy.mat,MARGIN=1,FUN=var,na.rm=TRUE)#
	Kbest.criteria3   <- which(Entropy.variation==min(Entropy.variation[-1]))#
	### Criteria 4: t-tests for entropy of each pairwise adjacent K#
	for(i in 2:nrow(crossentropy.mat)){#
		t.test.i <- t.test(crossentropy.mat[i-1,],crossentropy.mat[i,])#
		pval.i   <- t.test.i$p.value#
		stat.i   <- t.test.i$statistic#
		if(pval.i < 0.05 & stat.i > 0){#
			next#
		} else {#
			if(i==nrow(crossentropy.mat)){#
				Kbest.criteria4 <- NULL#
			} else{#
				Kbest.criteria4 <- (i-1)#
				break#
			}#
		}#
	}#
	####
	if(bestK>1){#
		segments(x0=bestK,y0=par("usr")[3],y1=par("usr")[4],lty=2)#
	}#
	mtext(side=1,"Number of ancestral populations",line=2.2)#
	mtext(side=2,"Cross-validation score",line=2.2)#
	mtext(side=3,paste0("Cross-validation score (",reps," replicates) vs. number of ancestral populations (K)"),line=1)#
	axis(1,at=Krange)#
	entropyPlot <- recordPlot()#
	## List holding population assignment probabilities for each K#
	slist <- lapply(X=Krange,FUN=function(x){as.data.frame(tess3r::qmatrix(tess3=tess.obj, K = x))})#
	par(mar=c(5.1,4.1,4.1,2.1),mfrow=c(1,1))#
	Krange.plot    <- setdiff(Krange,1)#
	admixturePlot  <- list(); length(admixturePlot)   <- length(Krange.plot)#
	mapplot        <- list(); length(mapplot)         <- length(Krange.plot)#
	x.min <- min((coords[,1]-0.5))#
	x.max <- max((coords[,1]+0.5))#
	y.min <- min((coords[,2]-0.5))#
	y.max <- max((coords[,2]+0.5))#
	for(K in Krange.plot){#
		i=(K-1)#
		q.matrix  <- slist[[K]]#
		rownames(q.matrix) <- samplenames#
		colnames(q.matrix) <- paste0("cluster",1:ncol(q.matrix))#
		posterior.df       <- data.frame(indv=rep(rownames(q.matrix),ncol(q.matrix)), pop=rep(colnames(q.matrix),each=nrow(q.matrix)), assignment=c(unlist(unname(q.matrix))))#
		if(K < 5){#
			myCols          <- goodcolors(K,thresh=100)#
		}#
		if(K >= 5 & K < 7){#
			myCols          <- goodcolors(K,thresh=100,cbspace="deut")#
		}#
		if(K >= 7 & K < 15){#
			myCols          <- goodcolors(K,thresh=100,cbspace="")#
		}#
		if(K>=15){#
			myCols          <- c(goodcolors(14,thresh=100,cbspace=""), sample(adegenet::funky(100), size=K-14))#
		}#
		posterior.gg        <- ggplot2::ggplot(posterior.df, aes(fill= pop, x= assignment, y=indv)) + geom_bar(position="stack", stat="identity") + theme_classic() + theme(axis.text.y = element_text(size = label.size), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank()) + ggplot2::labs(x = "Membership Probability",y="",fill="Cluster",title=paste0("K = ",K)) + scale_fill_manual(values=myCols[1:K])#
		plot(posterior.gg)#
		admixturePlot[[i]]   <- recordPlot()#
		my.palette   <- tess3r::CreatePalette(myCols, 9)#
		xdist        <- geosphere::distm(x=c(x.min,0),y=c(x.max,0))#
		ydist        <- geosphere::distm(x=c(0,y.min),y=c(0,y.max))#
		mapplot.initial <- plot(suppressWarnings(tess3r::as.qmatrix(q.matrix)), as.matrix(coords), method = "map.max", interpol = FieldsKrigModel(10), main = paste0("Ancestry coefficients; K=",K), xlab = "", ylab = "",resolution = c(100,100), cex = 0.4,col.palette = my.palette, window=c(x.min,x.max,y.min,y.max),asp=xdist/ydist)#
		mapplot.i       <- plot(suppressWarnings(tess3r::as.qmatrix(q.matrix)), as.matrix(coords), method = "map.max", interpol = FieldsKrigModel(10), main = paste0("Ancestry coefficients; K=",K), xlab = "", ylab = "",resolution = c(500,500), cex = 0.4,col.palette = my.palette, window=c(par("usr")[1],par("usr")[2],par("usr")[3],par("usr")[4]),asp=xdist/ydist)#
		mapplot[[i]]    <- recordPlot()#
	}#
	result <- c(list(entropyPlot),admixturePlot,mapplot)#
	if(!is.null(save.as)){#
		pdf(height=6,width=10,file=save.as,onefile=TRUE)#
		lapply(X=result,FUN=print)#
		dev.off()#
	}#
	result#
}
run_DAPC <- function(vcf, kmax=50, coords=NULL, reps=100,probs.out=NULL,save.as=NULL){#
	dev.new(width=10,height=6)#
	vcf.obj     <- vcfR::read.vcfR(vcf,verbose=F)#
	samplenames <- colnames(vcf.obj@gt)[-1]#
	genind      <- suppressWarnings(vcfR::vcfR2genind(vcf.obj))#
	numind      <- (dim(attributes(vcf.obj)[["gt"]])[2])-1#
	label.size  <- min((288/numind),7)#
	if(!is.null(coords)){#
		if(is(coords,"array") | is(coords,"data.frame")){#
			coords <-  coords#
		} else {#
			if(file.exists(coords)){#
				coords   <- read.table(coords)#
			}#
		}#
		x.min <- min((coords[,1]-0.5))#
		x.max <- max((coords[,1]+0.5))#
		y.min <- min((coords[,2]-0.5))#
		y.max <- max((coords[,2]+0.5))#
		maxK <- min(nrow(unique(coords)),(numind-1))#
	} else {#
		maxK <- (numind-1)#
	}#
	if(is.null(kmax)){#
		kmax <- maxK#
	} else {#
		if(kmax > maxK){#
			kmax <- maxK#
		}#
	}#
	max.clusters <- kmax#
	grp          <- adegenet::find.clusters(genind, max.n.clust=max.clusters,n.pca=max.clusters,choose.n.clust=F)#
	grp.list <- list(); length(grp.list) <- reps#
	par(mar=c(3.5,4,3,2.1))#
	for(i in 1:reps){#
		grp.list[[i]] <- adegenet::find.clusters(genind, max.n.clust=max.clusters,n.pca=max.clusters,choose.n.clust=F)#
	}#
	BIC.mat           <- do.call(cbind,lapply(X=1:reps,FUN=function(x){grp.list[[x]]$Kstat}))#
	rownames(BIC.mat) <- 1:max.clusters#
	colnames(BIC.mat) <- paste0("rep",1:reps)#
	boxplot(t(BIC.mat))#
	mean.BIC        <- apply(BIC.mat,MARGIN=1,FUN=mean,na.rm=TRUE)#
	### Lowest K with a lower mean BIC than K+1 mean BIC.#
	if(any(diff(mean.BIC)>0)){#
		bestK <- unname(which(diff(mean.BIC)>0)[1])#
	} else {#
		bestK <- 1#
	}#
	Kbest.criteria1   <- bestK#
	### Checking if the max BIC of the next K value is less than the min BIC of the previous K value.#
	range.BIC.mat     <- do.call(rbind,lapply(X=1:nrow(BIC.mat),FUN=function(x){range(BIC.mat[x,],na.rm=TRUE)}))#
	BIC.is.nonoverlap <- NULL#
	BIC.is.reduced    <- NULL#
	for(i in 2:nrow(range.BIC.mat)){#
		BIC.is.nonoverlap     <- c(BIC.is.nonoverlap,range.BIC.mat[i,1] > range.BIC.mat[(i-1),2] | range.BIC.mat[i,2] < range.BIC.mat[(i-1),1])#
		BIC.is.reduced     <- c(BIC.is.reduced,range.BIC.mat[i,2] < range.BIC.mat[(i-1),1])#
	}#
	# If max BIC for K=2 is better than BIC K=1 and if some K values are not better (all BIC lower) than K-1, then find the first K value in which K+1 is not better.#
	if(any(!BIC.is.reduced) & BIC.is.reduced[1]){#
		Kbest.criteria2 <- which(!BIC.is.reduced)[1]#
	} else {#
		Kbest.criteria2 <- 1#
	}#
	### Which K value (for K>=2) yields the least variable BIC scores.#
	BICvK.variation <- apply(X=BIC.mat,MARGIN=1,FUN=var)#
	KminVarBIC      <- which(BICvK.variation==min(BICvK.variation[-1]))#
	Kbest.criteria3 <- KminVarBIC#
	### Criteria 4: t-tests for BIC of each pairwise adjacent K#
	for(i in 2:nrow(BIC.mat)){#
		t.test.i <- t.test(BIC.mat[i-1,],BIC.mat[i,])#
		pval.i   <- t.test.i$p.value#
		stat.i   <- t.test.i$statistic#
		if(pval.i < 0.05 & stat.i > 0){#
			next#
		} else {#
			if(i==nrow(BIC.mat)){#
				Kbest.criteria4 <- NULL#
			} else{#
				Kbest.criteria4 <- (i-1)#
				break#
			}#
		}#
	}#
	if(bestK>1){#
		segments(x0=Kbest.criteria1, y0=par("usr")[3], y1=par("usr")[4],lty=2,col="black")#
	}#
	# segments(x0=Kbest.criteria1, y0=par("usr")[3], y1=par("usr")[4],lty=2,col="green")#
	# segments(x0=Kbest.criteria2, y0=par("usr")[3], y1=par("usr")[4],lty=2,col="blue")#
	# segments(x0=Kbest.criteria3, y0=par("usr")[3], y1=par("usr")[4],lty=2,col="orange")#
	mtext(side=1,"Number of ancestral populations",line=2.2)#
	mtext(side=2,"BIC",line=2.2)#
	mtext(side=3,paste0("BIC (",reps," replicates of find.clusters) vs. number of clusters (K)"),line=1)#
	axis(1,at=1:max.clusters)#
	BICPlot    <- recordPlot()#
	best.npca    <- NULL#
	grp.mat      <- matrix(data=0,nrow=length(grp$grp),ncol=(max.clusters-1))#
	for(K in 2:max.clusters){#
		i=(K-1)#
		grp.K         <- adegenet::find.clusters(genind, max.n.clust=max.clusters,n.pca=max.clusters,n.clust=K)#
		grp.mat[,i]   <- grp.K$grp#
		dapc.pcamax.K <- suppressWarnings(adegenet::dapc(genind, grp.K$grp,n.pca=max.clusters,n.da=5))#
		alpha_optim.K <- suppressWarnings(adegenet::optim.a.score(dapc.pcamax.K,plot=FALSE))#
		best.npca     <- c(best.npca,alpha_optim.K$best)#
	}#
	##### Plot 2: BIC vs. K when number of PCs retained = alpha optimized #
	par(mar=c(4,4,3,2.1))#
	names(best.npca) <- 2:max.clusters#
	barplot(best.npca)#
	mtext(text="Alpha optimized number of principle components to retain",side=2,line=2)#
	mtext(text="Number of clusters",side=1,line=2)#
	mtext(text="alpha optimized # of PCs vs. number of clusters",side=3,line=1)#
	grp.plot2      <- recordPlot()#
	par(mfrow=c(1,1))#
	admixturePlot  <- list(); length(admixturePlot)   <- max.clusters-1#
	assignmentPlot <- list(); length(assignmentPlot)  <- max.clusters-1#
	posterior.list <- list(); length(posterior.list)  <- max.clusters-1#
	mapplot <- list(); length(mapplot)  <- max.clusters-1#
	for(K in 2:max.clusters){#
		i=(K-1)#
		par(mar=c(5.1,4.1,4.1,2.1),mfrow=c(1,1))#
		dapc.pcabest.K  <- adegenet::dapc(genind, grp.mat[,i],n.pca=best.npca[i],n.da=5)#
		posterior       <- dapc.pcabest.K$posterior#
		q.matrix        <- posterior#
		posterior.list[[i]] <- posterior#
		posterior.df    <- data.frame(indv=rep(rownames(posterior),ncol(posterior)), pop=rep(colnames(posterior),each=nrow(posterior)), assignment=c(posterior))#
		if(K < 5){#
			myCols          <- goodcolors(K,thresh=100)#
		}#
		if(K >= 5 & K < 7){#
			myCols          <- goodcolors(K,thresh=100,cbspace="deut")#
		}#
		if(K >= 7 & K < 15){#
			myCols          <- goodcolors(K,thresh=100,cbspace="")#
		}#
		if(K>=15){#
			myCols          <- c(goodcolors(14,thresh=100,cbspace=""), sample(adegenet::funky(100), size=K-14))#
		}#
		posterior.gg        <- ggplot2::ggplot(posterior.df, aes(fill= pop, x= assignment, y=indv)) + geom_bar(position="stack", stat="identity") + theme_classic() + theme(axis.text.y = element_text(size = label.size), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank()) + ggplot2::labs(x = "Membership Probability",y="",fill="Cluster",title=paste0("K = ",K,"; PCs retained = ",best.npca[i])) + scale_fill_manual(values=myCols[1:K])#
		plot(posterior.gg)#
		admixturePlot[[i]]   <- recordPlot()#
		par(mar=c(5,20,2,2.1),mfrow=c(1,1))#
		assignment.K         <- adegenet::assignplot(dapc.pcabest.K,cex.lab=(label.size/10))#
		mtext(text=paste0("K = ",K,"; PCs retained = ",best.npca[i]))#
		assignmentPlot[[i]]  <- recordPlot()#
		par(mar=c(5.1,4.1,4.1,2.1),mfrow=c(1,1))#
		if(!is.null(coords)){#
			my.palette      <- tess3r::CreatePalette(myCols, 9)#
			xdist           <- geosphere::distm(x=c(x.min,0),y=c(x.max,0))#
			ydist           <- geosphere::distm(x=c(0,y.min),y=c(0,y.max))#
			tess3r.qmat     <- suppressWarnings(tess3r::as.qmatrix(q.matrix))#
			coords.mat      <- as.matrix(coords)#
			mapplot.initial <- plot(tess3r.qmat, coords.mat, method = "map.max", interpol = FieldsKrigModel(10), main = paste0("Ancestry coefficients; K=",K), xlab = "", ylab = "",resolution = c(100,100), cex = 0.4,col.palette = my.palette, window=c(x.min,x.max,y.min,y.max),asp=xdist/ydist)#
			mapplot.i       <- plot(tess3r.qmat, coords.mat, method = "map.max", interpol = FieldsKrigModel(10), main = paste0("Ancestry coefficients; K=",K), xlab = "", ylab = "",resolution = c(500,500), cex = 0.4,col.palette = my.palette, window=c(par("usr")[1],par("usr")[2],par("usr")[3],par("usr")[4]),asp=xdist/ydist)#
			mapplot[[i]]    <- recordPlot()#
		}#
	}#
	if(bestK>1){#
		posterior.bestK <- posterior.list[[bestK-1]]#
		colnames(posterior.bestK) <- paste0("K",colnames(posterior.bestK))#
		if(!is.null(probs.out)){#
			write.table(posterior.bestK,file=probs.out,quote=F,col.names=T,row.names=T)#
		}#
	} else {#
		posterior.bestK <- matrix(data=rep(1,numind),ncol=1)#
		rownames(posterior.bestK) <- samplenames#
	}#
	dev.off()#
	if(!is.null(coords)){#
		result <- c(list(BICPlot,grp.plot2),admixturePlot,assignmentPlot,mapplot)#
	} else {#
		result <- c(list(BICPlot,grp.plot2),admixturePlot,assignmentPlot)#
	}#
	if(!is.null(save.as)){#
		pdf(height=6,width=10,file=save.as,onefile=TRUE)#
		lapply(X=result,FUN=print)#
		dev.off()#
	}#
	result#
}
bothmodestum <- run_SNMF(vcf="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/Oxyrhabdium_both-modestum_BestSNP.vcf",#
	                           coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/tess3r/Oxyrhabdium_bothmodestum_coords.txt",#
	                           save.as="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/LEA/Oxyrhabdium_both-modestum_BestSNP_sNMF_run2.pdf")
source("/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/DAPC_adegenet.R")
q()
library(ade4)#
	library(adegenet)#
	library(vcfR)#
	library(ggplot2)#
	library(tess3r)#
	library(rworldmap)#
	library(LEA)#
	library(geosphere)#
	library(maps)#
	library(dartR)#
	source("/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/DAPC_adegenet.R")#
	source("/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/runtess.R")#
	source("/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/LEA/run_SNMF.R")
dev.new(width=10,height=6)
cfmodestum_Luzon <- run_DAPC(vcf="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/Oxyrhabdium-cf.modestum_Luzon_BestSNP.vcf",#
                            probs.out="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/Oxyrhabdium-cf.modestum_Luzon_BestSNP_DAPC_BestK_Membership_run2.txt",#
                            coords="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/tess3r/Oxyrhabdium-cfmodestum_Luzon_coords.txt",#
                            save.as="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/Oxyrhabdium-cfmodestum_Luzon_BestSNP_DAPC_run1.pdf")
vcf="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/Oxyrhabdium-cf.modestum_Luzon_BestSNP.vcf";#
                             probs.out="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/Oxyrhabdium-cf.modestum_Luzon_BestSNP_DAPC_BestK_Membership_run2.txt";#
                             coords="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/tess3r/Oxyrhabdium-cfmodestum_Luzon_coords.txt";#
                             save.as="/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/Oxyrhabdium-cfmodestum_Luzon_BestSNP_DAPC_run1.pdf"
kmax=50
reps=100
vcf.obj     <- vcfR::read.vcfR(vcf,verbose=F)#
	samplenames <- colnames(vcf.obj@gt)[-1]#
	genind      <- suppressWarnings(vcfR::vcfR2genind(vcf.obj))#
	numind      <- (dim(attributes(vcf.obj)[["gt"]])[2])-1#
	label.size  <- min((288/numind),7)
samplenames
!is.null(coords)
if(is(coords,"array") | is(coords,"data.frame")){#
			coords <-  coords#
		} else {#
			if(file.exists(coords)){#
				coords   <- read.table(coords)#
			}#
		}
coords
x.min <- min((coords[,1]-0.5))#
		x.max <- max((coords[,1]+0.5))#
		y.min <- min((coords[,2]-0.5))#
		y.max <- max((coords[,2]+0.5))#
		maxK <- min(nrow(unique(coords)),(numind-1))
if(is.null(kmax)){#
		kmax <- maxK#
	} else {#
		if(kmax > maxK){#
			kmax <- maxK#
		}#
	}
max.clusters <- kmax
grp          <- adegenet::find.clusters(genind, max.n.clust=max.clusters,n.pca=max.clusters,choose.n.clust=F)
for(i in 1:reps){#
		grp.list[[i]] <- adegenet::find.clusters(genind, max.n.clust=max.clusters,n.pca=max.clusters,choose.n.clust=F)#
	}#
	BIC.mat           <- do.call(cbind,lapply(X=1:reps,FUN=function(x){grp.list[[x]]$Kstat}))
grp.list <- list(); length(grp.list) <- reps#
	par(mar=c(3.5,4,3,2.1))#
	for(i in 1:reps){#
		grp.list[[i]] <- adegenet::find.clusters(genind, max.n.clust=max.clusters,n.pca=max.clusters,choose.n.clust=F)#
	}#
	BIC.mat           <- do.call(cbind,lapply(X=1:reps,FUN=function(x){grp.list[[x]]$Kstat}))
rownames(BIC.mat) <- 1:max.clusters#
	colnames(BIC.mat) <- paste0("rep",1:reps)#
	boxplot(t(BIC.mat))#
	mean.BIC        <- apply(BIC.mat,MARGIN=1,FUN=mean,na.rm=TRUE)
if(any(diff(mean.BIC)>0)){#
		bestK <- unname(which(diff(mean.BIC)>0)[1])#
	} else {#
		bestK <- 1#
	}#
	Kbest.criteria1   <- bestK
Kbest.criteria1
range.BIC.mat     <- do.call(rbind,lapply(X=1:nrow(BIC.mat),FUN=function(x){range(BIC.mat[x,],na.rm=TRUE)}))#
	BIC.is.nonoverlap <- NULL#
	BIC.is.reduced    <- NULL
range.BIC.mat
for(i in 2:nrow(range.BIC.mat)){#
		BIC.is.nonoverlap     <- c(BIC.is.nonoverlap,range.BIC.mat[i,1] > range.BIC.mat[(i-1),2] | range.BIC.mat[i,2] < range.BIC.mat[(i-1),1])#
		BIC.is.reduced     <- c(BIC.is.reduced,range.BIC.mat[i,2] < range.BIC.mat[(i-1),1])#
	}
if(any(!BIC.is.reduced) & BIC.is.reduced[1]){#
		Kbest.criteria2 <- which(!BIC.is.reduced)[1]#
	} else {#
		Kbest.criteria2 <- 1#
	}
BICvK.variation <- apply(X=BIC.mat,MARGIN=1,FUN=var)
BICvK.variation
KminVarBIC      <- which(BICvK.variation==min(BICvK.variation[-1]))
KminVarBIC
Kbest.criteria3 <- KminVarBIC[1]
Kbest.criteria3
for(i in 2:nrow(BIC.mat)){#
		t.test.i <- t.test(BIC.mat[i-1,],BIC.mat[i,])#
		pval.i   <- t.test.i$p.value#
		stat.i   <- t.test.i$statistic#
		if(pval.i < 0.05 & stat.i > 0){#
			next#
		} else {#
			if(i==nrow(BIC.mat)){#
				Kbest.criteria4 <- NULL#
			} else{#
				Kbest.criteria4 <- (i-1)#
				break#
			}#
		}#
	}
t.test.i <- t.test(BIC.mat[i-1,],BIC.mat[i,])
for(i in 2:nrow(BIC.mat)){#
		if(KminVarBIC==0){#
			Kbest.criteria4 <- NULL#
			break#
		}#
		t.test.i <- t.test(BIC.mat[i-1,],BIC.mat[i,])#
		pval.i   <- t.test.i$p.value#
		stat.i   <- t.test.i$statistic#
		if(pval.i < 0.05 & stat.i > 0){#
			next#
		} else {#
			if(i==nrow(BIC.mat)){#
				Kbest.criteria4 <- NULL#
			} else{#
				Kbest.criteria4 <- (i-1)#
				break#
			}#
		}#
	}
KminVarBIC==0
BICvK.variation[Kbest.criteria3]
for(i in 2:nrow(BIC.mat)){#
		if(BICvK.variation[Kbest.criteria3]==0){#
			Kbest.criteria4 <- NULL#
			break#
		}#
		t.test.i <- t.test(BIC.mat[i-1,],BIC.mat[i,])#
		pval.i   <- t.test.i$p.value#
		stat.i   <- t.test.i$statistic#
		if(pval.i < 0.05 & stat.i > 0){#
			next#
		} else {#
			if(i==nrow(BIC.mat)){#
				Kbest.criteria4 <- NULL#
			} else{#
				Kbest.criteria4 <- (i-1)#
				break#
			}#
		}#
	}
if(bestK>1){#
		segments(x0=Kbest.criteria1, y0=par("usr")[3], y1=par("usr")[4],lty=2,col="black")#
	}
bestK
if(bestK>1){#
		segments(x0=Kbest.criteria1, y0=par("usr")[3], y1=par("usr")[4],lty=2,col="black")#
	}
mtext(side=1,"Number of ancestral populations",line=2.2)#
	mtext(side=2,"BIC",line=2.2)#
	mtext(side=3,paste0("BIC (",reps," replicates of find.clusters) vs. number of clusters (K)"),line=1)
axis(1,at=1:max.clusters)#
	BICPlot    <- recordPlot()#
	best.npca    <- NULL#
	grp.mat      <- matrix(data=0,nrow=length(grp$grp),ncol=(max.clusters-1))#
	for(K in 2:max.clusters){#
		i=(K-1)#
		grp.K         <- adegenet::find.clusters(genind, max.n.clust=max.clusters,n.pca=max.clusters,n.clust=K)#
		grp.mat[,i]   <- grp.K$grp#
		dapc.pcamax.K <- suppressWarnings(adegenet::dapc(genind, grp.K$grp,n.pca=max.clusters,n.da=5))#
		alpha_optim.K <- suppressWarnings(adegenet::optim.a.score(dapc.pcamax.K,plot=FALSE))#
		best.npca     <- c(best.npca,alpha_optim.K$best)#
	}
##### Plot 2: BIC vs. K when number of PCs retained = alpha optimized #
	par(mar=c(4,4,3,2.1))#
	names(best.npca) <- 2:max.clusters#
	barplot(best.npca)#
	mtext(text="Alpha optimized number of principle components to retain",side=2,line=2)#
	mtext(text="Number of clusters",side=1,line=2)#
	mtext(text="alpha optimized # of PCs vs. number of clusters",side=3,line=1)#
	grp.plot2      <- recordPlot()#
	par(mfrow=c(1,1))#
	admixturePlot  <- list(); length(admixturePlot)   <- max.clusters-1#
	assignmentPlot <- list(); length(assignmentPlot)  <- max.clusters-1#
	posterior.list <- list(); length(posterior.list)  <- max.clusters-1#
	mapplot <- list(); length(mapplot)  <- max.clusters-1
for(K in 2:max.clusters){#
		i=(K-1)#
		par(mar=c(5.1,4.1,4.1,2.1),mfrow=c(1,1))#
		dapc.pcabest.K  <- adegenet::dapc(genind, grp.mat[,i],n.pca=best.npca[i],n.da=5)#
		posterior       <- dapc.pcabest.K$posterior#
		q.matrix        <- posterior#
		posterior.list[[i]] <- posterior#
		posterior.df    <- data.frame(indv=rep(rownames(posterior),ncol(posterior)), pop=rep(colnames(posterior),each=nrow(posterior)), assignment=c(posterior))#
		if(K < 5){#
			myCols          <- goodcolors(K,thresh=100)#
		}#
		if(K >= 5 & K < 7){#
			myCols          <- goodcolors(K,thresh=100,cbspace="deut")#
		}#
		if(K >= 7 & K < 15){#
			myCols          <- goodcolors(K,thresh=100,cbspace="")#
		}#
		if(K>=15){#
			myCols          <- c(goodcolors(14,thresh=100,cbspace=""), sample(adegenet::funky(100), size=K-14))#
		}#
		posterior.gg        <- ggplot2::ggplot(posterior.df, aes(fill= pop, x= assignment, y=indv)) + geom_bar(position="stack", stat="identity") + theme_classic() + theme(axis.text.y = element_text(size = label.size), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank()) + ggplot2::labs(x = "Membership Probability",y="",fill="Cluster",title=paste0("K = ",K,"; PCs retained = ",best.npca[i])) + scale_fill_manual(values=myCols[1:K])#
		plot(posterior.gg)#
		admixturePlot[[i]]   <- recordPlot()#
		par(mar=c(5,20,2,2.1),mfrow=c(1,1))#
		assignment.K         <- adegenet::assignplot(dapc.pcabest.K,cex.lab=(label.size/10))#
		mtext(text=paste0("K = ",K,"; PCs retained = ",best.npca[i]))#
		assignmentPlot[[i]]  <- recordPlot()#
		par(mar=c(5.1,4.1,4.1,2.1),mfrow=c(1,1))#
		if(!is.null(coords)){#
			my.palette      <- tess3r::CreatePalette(myCols, 9)#
			xdist           <- geosphere::distm(x=c(x.min,0),y=c(x.max,0))#
			ydist           <- geosphere::distm(x=c(0,y.min),y=c(0,y.max))#
			tess3r.qmat     <- suppressWarnings(tess3r::as.qmatrix(q.matrix))#
			coords.mat      <- as.matrix(coords)#
			mapplot.initial <- plot(tess3r.qmat, coords.mat, method = "map.max", interpol = FieldsKrigModel(10), main = paste0("Ancestry coefficients; K=",K), xlab = "", ylab = "",resolution = c(100,100), cex = 0.4,col.palette = my.palette, window=c(x.min,x.max,y.min,y.max),asp=xdist/ydist)#
			mapplot.i       <- plot(tess3r.qmat, coords.mat, method = "map.max", interpol = FieldsKrigModel(10), main = paste0("Ancestry coefficients; K=",K), xlab = "", ylab = "",resolution = c(500,500), cex = 0.4,col.palette = my.palette, window=c(par("usr")[1],par("usr")[2],par("usr")[3],par("usr")[4]),asp=xdist/ydist)#
			mapplot[[i]]    <- recordPlot()#
		}#
	}
if(bestK>1){#
		posterior.bestK <- posterior.list[[bestK-1]]#
		colnames(posterior.bestK) <- paste0("K",colnames(posterior.bestK))#
		if(!is.null(probs.out)){#
			write.table(posterior.bestK,file=probs.out,quote=F,col.names=T,row.names=T)#
		}#
	} else {#
		posterior.bestK <- matrix(data=rep(1,numind),ncol=1)#
		rownames(posterior.bestK) <- samplenames#
	}
if(!is.null(coords)){#
		result <- c(list(BICPlot,grp.plot2),admixturePlot,assignmentPlot,mapplot)#
	} else {#
		result <- c(list(BICPlot,grp.plot2),admixturePlot,assignmentPlot)#
	}
pdf(height=6,width=10,file=save.as,onefile=TRUE)
result
dev.off()
dev.new(height=6,width=10)
source("/Users/alyssaleinweber/Documents/Chapter4_Bicol-vs-Luzon/DAPC/DAPC_adegenet.R")
q()
library(remotes)
remotes::install_github("JeffWeinell/misc.wrappers",upgrade=FALSE,auth_token="323d9e4cd00247a39a805dbb66f37db6403cfb8b")
library(misc.wrappers)
q()
library(remotes)
install_github("JeffWeinell/misc.wrappers")
library(misc.wrappers)
x=file.path(system.file("extdata", package = "misc.wrappers"),"simK4.vcf.gz")
format="VCF"#
kmax=10#
coords="/Users/alyssaleinweber/Documents/misc.wrappers/inst/extdata/simK4_coords.txt"#
samplenames=NULL#
reps=30#
probs.out=NULL#
save.as="/Users/alyssaleinweber/Documents/DAPC_simK4_withCoords_v2.pdf"#
include.out=c(".pdf")
debug <- FALSE#
	if(is.null(save.as)){#
		save.as <- file.path(getwd(),"result_DAPC.pdf")#
	}#
	if(file.exists(save.as)){#
		stop("Output file already exists. Use a different name for 'save.as' argument.")#
	}
if(format=="VCF" | is(x,"vcfR")){#
		if(is(x,"vcfR")){#
			vcf.obj <- vcf <- x#
		} else {#
			vcf <- x#
			vcf.obj     <- vcfR::read.vcfR(vcf,verbose=F,checkFile=F)#
		}#
		if(is.null(samplenames)){#
			samplenames <- colnames(vcf.obj@gt)[-1]#
		}#
		genind      <- suppressWarnings(vcfR::vcfR2genind(vcf.obj))#
		#numind      <- (dim(attributes(vcf.obj)[["gt"]])[2])-1#
	} else {#
		stop("Currently, 'format' must be 'VCF'")#
	}
samplenames
numind      <- length(samplenames)#
	label.size  <- min((288/numind),7)
if(debug) message("step 0")
!is.null(coords)
is(coords,"array") | is(coords,"data.frame")
file.exists(coords)
coords   <- read.table(coords)
coords[1:10,]
x.min <- min((coords[,1]-0.5))#
		x.max <- max((coords[,1]+0.5))#
		y.min <- min((coords[,2]-0.5))#
		y.max <- max((coords[,2]+0.5))
x.min
x.max
y.min
y.max
maxK  <- min(nrow(unique(coords)),(numind-1))
maxK
world_sf      <- rnaturalearth::ne_countries(scale=10,returnclass="sf")[1]#
		world_sp      <- rnaturalearth::ne_countries(scale=10,returnclass="sp")
current_sf    <- suppressMessages(sf::st_crop(world_sf,xmin=x.min,xmax=x.max,ymin=y.min,ymax=y.max))#
		current.gg.sf <- ggplot2::geom_sf(data=current_sf,colour = "black", fill = NA)
current_sf    <- suppressWarnings(suppressMessages(sf::st_crop(world_sf,xmin=x.min,xmax=x.max,ymin=y.min,ymax=y.max)))
current.gg.sf <- ggplot2::geom_sf(data=current_sf,colour = "black", fill = NA)
current.gg.sf
plot(current.gg.sf)
class(current.gg.sf)
current.gg.sf2 <- ggplot2::geom_sf(data=world_sf) + sf::geom_coord(xmin=x.min,xmax=x.max,ymin=y.min,ymax=y.max)
current.gg.sf2 <- ggplot2::geom_sf(data=world_sf) + sf::coord_sf(xmin=x.min,xmax=x.max,ymin=y.min,ymax=y.max)
current.gg.sf2 <- ggplot2::geom_sf(data=world_sf) + ggplot2::coord_sf(xmin=x.min,xmax=x.max,ymin=y.min,ymax=y.max)
current.gg.sf2 <- ggplot2::geom_sf(data=world_sf) + ggplot2::coord_sf(xlim=c(x.min,x.max),ylim=c(y.min,ymax=y.max))
maxK
numind
if(is.null(kmax)){#
		kmax <- maxK#
	} else {#
		if(kmax > maxK){#
			kmax <- maxK#
		}#
	}#
	max.clusters <- kmax#
	Krange       <- 1:max.clusters
Krange
max.clusters
if(max.clusters <= 15){#
			myCols  <- goodcolors2(n=max.clusters)#
		}#
		if(max.clusters>15){#
			myCols  <- c(goodcolors2(n=15), sample(adegenet::funky(100), size=max.clusters-15))#
	}
myCols
if(debug) message("step 1")#
	#### find.clusters#
	grp          <- adegenet::find.clusters(genind, max.n.clust=max.clusters,n.pca=max.clusters,choose.n.clust=F)
grp.list     <- list(); length(grp.list) <- reps#
	# par(mar=c(3.5,4,3,2.1))#
	for(i in 1:reps){#
		grp.list[[i]] <- adegenet::find.clusters(genind, max.n.clust=max.clusters,n.pca=max.clusters,choose.n.clust=F)#
	}
rownames(BIC.mat) <- 1:max.clusters#
	colnames(BIC.mat) <- paste0("rep",1:reps)#
	mean.BIC        <- apply(BIC.mat,MARGIN=1,FUN=mean,na.rm=TRUE)
BIC.mat           <- do.call(cbind,lapply(X=1:reps,FUN=function(x){grp.list[[x]]$Kstat}))
rownames(BIC.mat) <- 1:max.clusters#
	colnames(BIC.mat) <- paste0("rep",1:reps)#
	mean.BIC        <- apply(BIC.mat,MARGIN=1,FUN=mean,na.rm=TRUE)
if(any(diff(mean.BIC)>0)){#
		bestK <- unname(which(diff(mean.BIC)>0)[1])#
	} else {#
		bestK <- 1#
	}#
	Kbest.criteria1   <- bestK
BIC.df      <- data.frame(BIC=unname(unlist(c(BIC.mat))),K=rep(Krange,reps),replicate=rep(1:reps,each=length(Krange)))#
	### save a copy of BIC scores#
	if(".BIClog" %in% include.out){#
		write.table(x=BIC.df,file=paste0(tools::file_path_sans_ext(save.as),".BIClog"),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")#
	}
BIC.df$K <- factor(BIC.df$K, levels=c(1:nrow(BIC.df)))#
	BICPlot  <- ggplot2::ggplot(data=BIC.df,ggplot2::aes(x=K, y=BIC)) + ggplot2::geom_boxplot(fill='lightgray', outlier.colour="black", outlier.shape=16,outlier.size=2, notch=FALSE) + ggplot2::theme_classic() + ggplot2::labs(title= paste0("BIC (",reps," replicates of find.clusters) vs. number of clusters (K)"), x="Number of ancestral populations", y = "BIC") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) # + ggplot2::geom_vline(xintercept=bestK, linetype=2, color="black", size=0.25)#
	if(debug) message("step 1.5")#
	best.npca  <- NULL#
	grp.mat    <- matrix(data=0,nrow=length(grp$grp),ncol=(max.clusters-1))
for(K in 2:max.clusters){#
		i=(K-1)#
		grp.K         <- adegenet::find.clusters(genind, max.n.clust=max.clusters,n.pca=max.clusters,n.clust=K)#
		grp.mat[,i]   <- grp.K$grp#
		dapc.pcamax.K <- suppressWarnings(adegenet::dapc(genind, grp.K$grp,n.pca=max.clusters,n.da=5))#
		alpha_optim.K <- suppressWarnings(adegenet::optim.a.score(dapc.pcamax.K,plot=FALSE))#
		best.npca     <- c(best.npca,alpha_optim.K$best)#
	}#
	if(debug) message("step 2")
best.npca.df      <- data.frame(K=2:max.clusters,best.npca=best.npca)#
	best.npca.df$K    <- factor(best.npca.df$K)#
	grp.plot2         <- ggplot2::ggplot(data=best.npca.df, ggplot2::aes(x=K,y=best.npca)) + ggplot2::geom_bar(stat="identity",fill="lightgray") + ggplot2::labs(title= "alpha optimized # of PCs vs. number of clusters", x="Number of clusters", y = "Alpha optimized number of principle components to retain") + ggplot2::theme_classic() + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5))
empty.set <- list(); length(empty.set) <- max.clusters-1#
	dapc.pcabest.list <- admixturePlot <- da.densityPlot <- da.biPlot <- pca.densityPlot <- pca.biPlot <- da.psets <- da.layout.mat<- pca.psets <- pca.layout.mat <- assignmentPlot <- posterior.list <- mapplot <- q.df <- dapc.df <- empty.set
dapc.list <- empty.set#
	for(K in 2:max.clusters){#
		i=K-1#
		dapc.list[[(i)]] <- adegenet::dapc(genind, grp.mat[,i],n.pca=best.npca[i],n.da=5)#
	}
names(dapc.list) <- paste0("K",c(2:max.clusters))#
	grp.assignments.mat <- do.call(cbind,lapply(dapc.list,FUN=function(x){c(x$assign)}))#
	rownames(grp.assignments.mat) <- samplenames#
	colnames(grp.assignments.mat) <- paste0("K",c(2:max.clusters))#
	grp.minsizes <- apply(grp.assignments.mat,MARGIN=2,FUN=function(x){min(table(x))})
if(any((grp.minsizes > 1))){#
		Ks.showdensity <- unname(which((grp.minsizes > 1))+1)#
	}
posterior.list <- lapply(dapc.list,function(x){x$posterior})#
	# Number of discriminant functions retained at each value of K#
	Ks.n.da        <- sapply(dapc.list,function(x){x$n.da})#
	# Number of principle components retained at each value of K#
	Ks.n.pca       <- sapply(dapc.list,function(x){x$n.pca})#
	# Data frame holding assignment probability of each individual in each cluster at each K.#
	q.df           <- do.call(rbind,lapply(X=1:length(dapc.list),FUN=function(x){data.frame(indv=rep(rownames(posterior.list[[x]]),ncol(posterior.list[[x]])), pop=rep(colnames(posterior.list[[x]]),each=nrow(posterior.list[[x]])), assignment=c(posterior.list[[x]]),K=(x+1))}))
if(".Qlog" %in% include.out){#
		write.table(x=q.df,file=paste0(tools::file_path_sans_ext(save.as),".Qlog"),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")#
	}
plottable   <- plottable.dapc(dapc.list)#
	K.plottable <- as.numeric(rownames(plottable$DF))
indexmat.da <- apply(matrix(1:length(plottable$DF),ncol=ncol(plottable$DF)),2,rev)#
	indexmat.pc <- apply(matrix(1:length(plottable$PC),ncol=ncol(plottable$PC)),2,rev)
emptymat.da  <- matrix(data=rep("",length(plottable$DF)),ncol=ncol(plottable$DF))#
	emptymat.pca <- matrix(data=rep("",length(plottable$PC)),ncol=ncol(plottable$PC))#
	left.mat.da  <- bottom.mat.da  <- right.mat.da  <- top.mat.da  <-emptymat.da#
	left.mat.pca <- bottom.mat.pca <- right.mat.pca <- top.mat.pca <-emptymat.pca#
	left.mat.da[,1]  <- left.mat.pca[,1] <- rev(paste0("K",K.plottable))#
	right.mat.da[,ncol(plottable$DF)] <- right.mat.pca[,ncol(plottable$PC)] <- rev(paste0("K",K.plottable))#
	bottom.mat.da[nrow(plottable$DF),]  <- colnames(plottable$DF)#
	bottom.mat.pca[nrow(plottable$PC),] <- colnames(plottable$PC)#
	top.mat.da[1,]  <- colnames(plottable$DF)#
	top.mat.pca[1,] <- colnames(plottable$PC)
df.plots.list <- list(); length(df.plots.list) <- length(plottable$DF)#
	ctr <- 0
for(j in 1:ncol(plottable$DF)){#
		for(i in 1:nrow(plottable$DF) ){#
			ctr <- ctr+1#
			if(!plottable$DF[i,j]){#
			#	next#
				plot.ij  <- grid::rectGrob(gp=grid::gpar(col=NA))#
			} else {#
			#	ctr <- ctr+1#
				plot.ij  <- ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K.plottable[i]-1)]], vartype="df", xax=j, yax=j, col=myCols, legend=F, show.title=F, hideperimeter=T))#
			}#
			df.plots.list[[ctr]]        <- plot.ij#
			names(df.plots.list)[[ctr]] <- paste0("K",K.plottable[i],".DF",j)#
		}#
	}
da.arranged0   <- lapply(X=1:length(df.plots.list),FUN=function(x){gridExtra::arrangeGrob(df.plots.list[[x]],left=left.mat.da[indexmat.da[x]],right=right.mat.da[indexmat.da[x]],bottom=bottom.mat.da[indexmat.da[x]],top=top.mat.da[indexmat.da[x]])})#
	da.arranged    <- gridExtra::arrangeGrob(grobs=da.arranged0,layout_matrix=indexmat.da,respect=TRUE)#
	vp             <- grid::viewport(height=grid::unit(0.9,"npc"),width=grid::unit(0.9,"npc"))#
	pdf(file=paste0(tools::file_path_sans_ext(save.as),"_desnsityPlots_DF.pdf"), height=(nrow(indexmat.da)*3),width=(ncol(indexmat.da)*3))#
	grid::grid.draw(da.arranged)#
	dev.off()
pc.plots.list <- list(); length(pc.plots.list) <- length(plottable$PC)#
	ctr <- 0
for(j in 1:ncol(plottable$PC)){#
		for(i in 1:nrow(plottable$PC) ){#
			ctr <- ctr+1#
			if(!plottable$PC[i,j]){#
			#	next#
				plot.ij  <- grid::rectGrob(gp=grid::gpar(col=NA))#
			} else {#
			#	ctr <- ctr+1#
				plot.ij  <- ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K.plottable[i]-1)]], vartype="pc", xax=j, yax=j, col=myCols, legend=F, show.title=F, hideperimeter=T))#
			}#
			pc.plots.list[[ctr]]        <- plot.ij#
			names(pc.plots.list)[[ctr]] <- paste0("K",K.plottable[i],".PC",j)#
		}#
	}
pc.arranged0   <- lapply(X=1:length(pc.plots.list),FUN=function(x){gridExtra::arrangeGrob(pc.plots.list[[x]],left=left.mat.pca[indexmat.pc[x]],right=right.mat.pca[indexmat.pc[x]],bottom=bottom.mat.pca[indexmat.pc[x]],top=top.mat.pca[indexmat.pc[x]])})#
	pc.arranged    <- gridExtra::arrangeGrob(grobs=pc.arranged0,layout_matrix=indexmat.pc,respect=TRUE)#
	vp             <- grid::viewport(height=grid::unit(0.9,"npc"),width=grid::unit(0.9,"npc"))#
	pdf(file=paste0(tools::file_path_sans_ext(save.as),"_desnsityPlots_PC.pdf"), height=(nrow(indexmat.pc)*3),width=(ncol(indexmat.pc)*3))#
	grid::grid.draw(pc.arranged)#
	dev.off()
any(Ks.n.da>2)
if(any(Ks.n.da>2)){#
		#distmats.da <- lapply(apply(plottable$DF[apply(plottable$DF,MARGIN=1,FUN=function(x){length(which(x))>2}),],MARGIN=1,FUN=which), FUN=function(y){dist(y)})#
		distmats.da <- lapply(X=Ks.n.da[which(Ks.n.da>1)], FUN=function(x){dist(table(paste0("DF",c(1:x))))})#
		distlabs.da <- lapply(distmats.da,FUN=function(x){gtools::mixedsort(attributes(x)$Labels)})#
		#damats0  <- lapply(apply(plottable$DF[apply(plottable$DF,MARGIN=1,FUN=function(x){length(which(x))>2}),],MARGIN=1,FUN=which), FUN=function(y){lower.tri(dist(y))})#
		damats0  <- lapply(distmats.da, FUN=lower.tri)#
		davals   <- lapply(damats0,FUN=function(x){1:length(which(x))})#
		damats1  <- damats0#
		for(i in 1:length(damats1)){#
			damats1[[i]][damats0[[i]]]  <- davals[[i]]#
			damats1[[i]][!damats0[[i]]] <- NA#
			damats1[[i]] <- damats1[[i]] # [-c(1),-c(ncol(damats1[[i]]))]#
			rownames(damats1[[i]]) <- distlabs.da[[i]] # [-1]#
			colnames(damats1[[i]]) <- distlabs.da[[i]] # [-c(lengths(distlabs.da)[i])]#
		}#
		damats2 <- damats1#
		for(i in 1:length(damats2)){#
			damats2[[i]][!is.na(damats2[[i]])] <- paste0("bp",damats2[[i]][!is.na(damats2[[i]])],".da")#
			damats2[[i]] <- t(damats2[[i]])#
		}#
	}
if(any(Ks.n.pca>2)){#
		#distmats.pc <- lapply(apply(plottable$PC[apply(plottable$PC,MARGIN=1,FUN=function(x){length(which(x))>2}),],MARGIN=1,FUN=which), FUN=function(y){dist(y)})#
		distmats.pc <- lapply(X=Ks.n.pca[which(Ks.n.pca>1)], FUN=function(x){dist(table(paste0("DF",c(1:x))))})#
		distlabs.pc <- lapply(distmats.pc,FUN=function(x){gtools::mixedsort(attributes(x)$Labels)})#
		#pcmats0  <- lapply(apply(plottable$PC[apply(plottable$PC,MARGIN=1,FUN=function(x){length(which(x))>2}),],MARGIN=1,FUN=which), FUN=function(y){lower.tri(dist(y))})#
		pcmats0  <- lapply(distmats.pc,lower.tri)#
		pcvals   <- lapply(pcmats0,FUN=function(x){1:length(which(x))})#
		pcmats1  <- pcmats0#
		for(i in 1:length(pcmats1)){#
			pcmats1[[i]][pcmats0[[i]]]  <- pcvals[[i]]#
			pcmats1[[i]][!pcmats0[[i]]] <- NA#
			pcmats1[[i]] <- pcmats1[[i]]   # [-c(1),-c(ncol(pcmats1[[i]]))]#
			rownames(pcmats1[[i]]) <- distlabs.pc[[i]]  #[-1]#
			colnames(pcmats1[[i]]) <- distlabs.pc[[i]]  # [-c(lengths(distlabs.pc)[i])]#
		}#
		pcmats2 <- pcmats1#
		for(i in 1:length(pcmats2)){#
			pcmats2[[i]][!is.na(pcmats2[[i]])] <- paste0("bp",pcmats2[[i]][!is.na(pcmats2[[i]])],".pc")#
		}#
	}
dapc.mats <- pcmats2
for(i in 1:length(dapc.mats)){#
		dapc.mats[[i]][which(is.na(pcmats2[[i]]))[1:length(c(damats2[[i]][!lower.tri(damats2[[i]])]))]] <- c(damats2[[i]][!lower.tri(damats2[[i]])])#
		colnames(dapc.mats[[i]]) <- 1:ncol(dapc.mats[[i]])#
	}
da.psets <- lapply(X=1:length(Ks.n.da),FUN=function(x){ do.call(rbind, pset(x=1:Ks.n.da[x], min.length=2, max.length=2))})#
	da.psets2 <- lapply(which(lengths(da.psets)>0), FUN=function(x){da.psets[[x]][order(c(da.psets[[x]][,1]),c( da.psets[[x]][,2])),]})#
	names(da.psets2) <- which(lengths(da.psets)>0)+1
pca.psets <- lapply(X=1:length(Ks.n.pca),FUN=function(x){ do.call(rbind, pset(x=1:Ks.n.pca[x], min.length=2, max.length=2))})#
	pca.psets2 <- lapply(which(lengths(pca.psets)>0), FUN=function(x){pca.psets[[x]][order(c(pca.psets[[x]][,1]),c( pca.psets[[x]][,2])),]})#
	names(pca.psets2) <- which(lengths(pca.psets)>0)+1
df.biplots.list <- list(); length(df.biplots.list) <- length(da.psets2)
for(i in 1:length(da.psets2)){#
		K <- as.numeric(names(da.psets2))[i]#
		df.biplots.list[[i]] <- lapply(X=1:nrow(da.psets2[[i]]), FUN=function(x){ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K-1)]], vartype="df", xax=da.psets2[[i]][x,1], yax=da.psets2[[i]][x,2], col=myCols, legend=F, show.title=F, hideperimeter=T,cellipse=0))})#
		# Names matching those used in 'dapc.mats'#
		names(df.biplots.list[[i]]) <- c(t(damats2[[i]]))[!is.na(c(t(damats2[[i]])))]#
	}
i
df.biplots.list <- list(); length(df.biplots.list) <- length(da.psets2)
length(df.biplots.list)
length(da.psets2)
i=1
K <- as.numeric(names(da.psets2))[i]#
		df.biplots.list[[i]] <- lapply(X=1:nrow(da.psets2[[i]]), FUN=function(x){ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K-1)]], vartype="df", xax=da.psets2[[i]][x,1], yax=da.psets2[[i]][x,2], col=myCols, legend=F, show.title=F, hideperimeter=T,cellipse=0))})
class(da.psets2)
class(da.psets2[[1]])
da.psets2[[1]]
da.psets2
class(da.psets2[[2]])
as.matrix(  da.psets2[[i]],ncol=2)
as.matrix(  da.psets2[[1]],ncol=2)
rbind(da.psets2[[i]])
df.biplots.list[[i]] <- lapply(X=1:nrow(rbind(da.psets2[[i]])), FUN=function(x){ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K-1)]], vartype="df", xax=da.psets2[[i]][x,1], yax=da.psets2[[i]][x,2], col=myCols, legend=F, show.title=F, hideperimeter=T,cellipse=0))})
i
nrow( rbind(da.psets2[[i]]))
df.biplots.list[[i]] <- lapply(X=1:nrow(rbind(da.psets2[[i]])), FUN=function(x){ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K-1)]], vartype="df", xax= rbind(da.psets2[[i]]) [x,1], yax=rbind(rda.psets2[[i]])[x,2], col=myCols, legend=F, show.title=F, hideperimeter=T,cellipse=0))})
df.biplots.list[[i]] <- lapply(X=1:nrow(rbind(da.psets2[[i]])), FUN=function(x){ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K-1)]], vartype="df", xax= rbind(da.psets2[[i]]) [x,1], yax=rbind(da.psets2[[i]])[x,2], col=myCols, legend=F, show.title=F, hideperimeter=T,cellipse=0))})
names(df.biplots.list[[i]]) <- c(t(damats2[[i]]))[!is.na(c(t(damats2[[i]])))]
df.biplots.list[[1]]
dapc.mats2 <- dapc.mats#
	for(i in 1:length(dapc.mats2)){#
		dapc.mats2[[i]] <- unname(dapc.mats[[i]][!apply(dapc.mats[[i]],MARGIN=1,FUN=function(x){all(is.na(x))}),!apply(dapc.mats[[i]],MARGIN=2,FUN=function(x){all(is.na(x))})])#
	}
pc.biplots.list
pc.biplots.list <- list(); length(pc.biplots.list) <- length(pca.psets2)#
	for(i in 1:length(pca.psets2)){#
		K <- as.numeric(names(pca.psets2))[i]#
		pc.biplots.list[[i]] <- lapply(X=1:nrow(pca.psets2[[i]]), FUN=function(x){ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K-1)]], vartype="pc", xax=pca.psets2[[i]][x,1], yax=pca.psets2[[i]][x,2], col=myCols, legend=F, show.title=F, hideperimeter=T,cellipse=0))})#
		names(pc.biplots.list[[i]]) <- c(pcmats2[[i]])[!is.na(c(pcmats2[[i]]))]#
	}
pca.psets2[[i]]
pc.biplots.list[[i]] <- lapply(X=1:nrow(rbind(pca.psets2[[i]])), FUN=function(x){ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K-1)]], vartype="pc", xax=rbind(pca.psets2[[i]])[x,1], yax=rbind(pca.psets2[[i]])[x,2], col=myCols, legend=F, show.title=F, hideperimeter=T,cellipse=0))})
df.biplots.list <- list(); length(df.biplots.list) <- length(da.psets2)#
	for(i in 1:length(da.psets2)){#
		K <- as.numeric(names(da.psets2))[i]#
		df.biplots.list[[i]] <- lapply(X=1:nrow(rbind(da.psets2[[i]])), FUN=function(x){ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K-1)]], vartype="df", xax= rbind(da.psets2[[i]]) [x,1], yax=rbind(da.psets2[[i]])[x,2], col=myCols, legend=F, show.title=F, hideperimeter=T,cellipse=0))})#
		# Names matching those used in 'dapc.mats'#
		names(df.biplots.list[[i]]) <- c(t(damats2[[i]]))[!is.na(c(t(damats2[[i]])))]#
	}#
	#### Generate PC biplots.#
	pc.biplots.list <- list(); length(pc.biplots.list) <- length(pca.psets2)#
	for(i in 1:length(pca.psets2)){#
		K <- as.numeric(names(pca.psets2))[i]#
		pc.biplots.list[[i]] <- lapply(X=1:nrow(rbind(pca.psets2[[i]])), FUN=function(x){ggplot2::ggplotGrob(ggscatter.dapc(dapc.list[[(K-1)]], vartype="pc", xax=rbind(pca.psets2[[i]])[x,1], yax=rbind(pca.psets2[[i]])[x,2], col=myCols, legend=F, show.title=F, hideperimeter=T,cellipse=0))})#
		names(pc.biplots.list[[i]]) <- c(pcmats2[[i]])[!is.na(c(pcmats2[[i]]))]#
	}
dapc.mats2 <- dapc.mats#
	for(i in 1:length(dapc.mats2)){#
		dapc.mats2[[i]] <- unname(dapc.mats[[i]][!apply(dapc.mats[[i]],MARGIN=1,FUN=function(x){all(is.na(x))}),!apply(dapc.mats[[i]],MARGIN=2,FUN=function(x){all(is.na(x))})])#
	}
dapc.mats3 <- lapply(dapc.mats2,apply,2,rev)#
	### Index matrix#
	index.bi <- lapply(1:length(dapc.mats3),FUN=function(x){ apply(matrix(data=c(1:length(dapc.mats3[[x]])) ,ncol=ncol(dapc.mats3[[x]])),2,rev)  })#
	### Emptry matrices#
	empty.bi <- lapply(1:length(dapc.mats3),FUN=function(x){matrix(data=rep("",length(dapc.mats3[[x]])),ncol=ncol(dapc.mats3[[x]]))})
Ks.n.da.bi  <- Ks.n.da[which(Ks.n.da>1)]#
	Ks.n.pca.bi <- Ks.n.pca[which(Ks.n.pca>1)]
left.mat.bi <- right.mat.bi <- bottom.mat.bi <- top.mat.bi <- empty.bi
length(dapc.mats3)
for(i in 1:length(dapc.mats3)){#
		left.mat.bi[[i]][,1]   <- rev(c("",paste0("PC",2:Ks.n.pca.bi[i])))#
		right.mat.bi[[i]][,ncol(right.mat.bi[[i]])]  <- rev(c(paste0("DF", 1:(Ks.n.da.bi[i]-1)),rep("",(nrow(right.mat.bi[[i]])-(Ks.n.da.bi[i]-1)))))#
		bottom.mat.bi[[i]][nrow(bottom.mat.bi[[i]]),] <- c(rep("",(ncol(bottom.mat.bi[[i]])- (Ks.n.da.bi[i]-1) )),paste0("DF",2:(Ks.n.da.bi[i])))#
		top.mat.bi[[i]][1,]  <- c(paste0("PC", (1:(Ks.n.pca.bi[i]-1))), rep("",(ncol(top.mat.bi[[i]])-(Ks.n.pca.bi[i]-1))))#
	}
bi.arranged0 <- list(); length(bi.arranged0) <- length(dapc.mats3)#
	bi.arranged  <- list(); length(bi.arranged) <- length(dapc.mats3)
for(i in 1:length(dapc.mats3)){#
		for(j in 1:length(dapc.mats3[[i]])){#
			plot.name <- dapc.mats3[[i]][which(index.bi[[i]]==j)]#
			if(is.na(plot.name)){#
				plot.ij <- grid::rectGrob(gp=grid::gpar(col=NA))#
			} else {#
				if(plot.name %in% names(pc.biplots.list[[i]])){#
					plot.ij <- pc.biplots.list[[i]][plot.name][[1]]#
				} else {#
					if(plot.name %in% names(df.biplots.list[[i]])){#
						plot.ij <- df.biplots.list[[i]][plot.name][[1]]#
					}#
				}#
			}#
			bi.arranged0[[i]][[j]] <- gridExtra::arrangeGrob(plot.ij,left=left.mat.bi[[i]][which(index.bi[[i]]==j)],right=right.mat.bi[[i]][which(index.bi[[i]]==j)],bottom=bottom.mat.bi[[i]][which(index.bi[[i]]==j)],top=top.mat.bi[[i]][which(index.bi[[i]]==j)])#
		}#
		bi.arranged[[i]] <- gridExtra::arrangeGrob(grobs=bi.arranged0[[i]],layout_matrix=index.bi[[i]],respect=TRUE)#
		#test <- gridExtra::arrangeGrob(grobs=bi.arranged0[[i]],layout_matrix=index.bi,respect=TRUE)#
	}
vp             <- grid::viewport(height=grid::unit(0.95,"npc"),width=grid::unit(0.95,"npc"))#
	pdf(file=paste0(tools::file_path_sans_ext(save.as),"_BiPlots.pdf"), height=(max(sapply(dapc.mats3,nrow))*3),width=(max(sapply(dapc.mats3,ncol))*3))#
	for(i in 1:length(dapc.mats3)){#
		grid::grid.draw(bi.arranged[[i]])#
		if(i < length(dapc.mats3)){#
			grid::grid.newpage()#
		}#
	}#
	dev.off()
if(debug) message("step 3")#
	density.stop<-FALSE
K
K=2
if(debug) message(paste0("K=",K," step 3.1"))#
		i=(K-1)#
		#dapc.pcabest.K      <- adegenet::dapc(genind, grp.mat[,i],n.pca=best.npca[i],n.da=5)#
		dapc.pcabest.K      <- dapc.list[[i]]#
		### Fewest number of individuals assigned to any cluster.#
		minsize.grp <- min(table(as.numeric(dapc.pcabest.K$assign)))#
		# switch density.stop to TRUE the first time minsize.grp is 1#
		if(!(minsize.grp > 1) & !density.stop){#
			density.stop <- TRUE#
		}#
		#if(!(minsize.grp < 4)){#
		#	ellipse.size <- 0#
		#} else {#
		#	ellipse.size <- 1.5#
		#}#
#		dapc.pcabest.list[[i]] <- dapc.pcabest.K#
#		posterior           <- dapc.pcabest.K$posterior#
#		q.matrix            <- posterior#
#		posterior           <- posterior.list[[i]]#
#		posterior.df        <- data.frame(indv=rep(rownames(posterior),ncol(posterior)), pop=rep(colnames(posterior),each=nrow(posterior)), assignment=c(posterior),K=K)#
		q.matrix            <- posterior.list[[i]]#
		posterior.df        <- q.df[q.df$K==K,]
if(debug) message(cat("\r",paste0("K=",K," step 3.3")))#
		### biplots of discriminant functions
dapc.pcabest.K$n.da>1
dapc.pcabest.K$n.da
biplots.da.list.i
exists(da.psets)
da.psets[[]]
da.psets[[1]]
posterior.gg        <- ggplot2::ggplot(posterior.df, ggplot2::aes(fill= pop, x= assignment, y=indv)) + ggplot2::geom_bar(position="stack", stat="identity") + ggplot2::theme_classic() + ggplot2::theme(axis.text.y = ggplot2::element_text(size = label.size), panel.grid.major = ggplot2::element_blank(), panel.grid.minor = ggplot2::element_blank(), panel.background = ggplot2::element_blank()) + ggplot2::labs(x = "Membership Probability",y="",fill="Cluster",title=paste0("K = ",K,"; PCs retained = ",best.npca[i])) + ggplot2::scale_fill_manual(values=myCols[1:K])#
		admixturePlot[[i]]  <- posterior.gg#
		#indv.KmaxPosterior <- apply(X=q.matrix, MARGIN=1, FUN=function(x){which(x==max(x))})#
		if(debug) message(cat("\r",paste0("K=",K," step 3.7")))#
		indv.maxPosterior  <- apply(X=q.matrix, MARGIN=1, FUN=function(x){max(x)})#
		labels             <- rep("",nrow(posterior.df))#
		labels[posterior.df[,"assignment"] %in% indv.maxPosterior] <- "+"#
		assignment.K        <- ggplot2::ggplot(data=posterior.df, ggplot2::aes(x= pop, y=indv,fill=assignment)) + ggplot2::geom_tile(color="gray") + ggplot2::theme_classic() + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5), axis.text.y = ggplot2::element_text(size = label.size), panel.grid.major = ggplot2::element_blank(), panel.grid.minor = ggplot2::element_blank(), panel.background = ggplot2::element_blank(), legend.position = "none", ) + ggplot2::labs(title = paste0("K = ",K,"; PCs retained = ", best.npca[i]), x="Clusters", y="") + ggplot2::scale_fill_gradient2(low = "white", mid = "yellow", high = "red", midpoint = 0.5) + ggplot2::geom_text(label=labels)#
		assignmentPlot[[i]] <- assignment.K#
		if(debug) message(cat("\r",paste0("K=",K," step 3.8")))
!is.null(coords)
my.palette      <- tess3r::CreatePalette(myCols[1:K], 9)#
			tess3r.qmat     <- suppressWarnings(tess3r::as.qmatrix(q.matrix))#
			coords.mat      <- as.matrix(coords)
coords.mat[1:10,]
mapplot.i       <- tess3r::ggtess3Q(tess3r.qmat,coords.mat, interpolation.model = tess3r::FieldsKrigModel(10),resolution = c(500,500), col.palette = my.palette, window=c(x.min,x.max,y.min,y.max),background=TRUE,map.polygon=world_sp)
coords.mat      <- as.matrix(coords)[,1:2]
coords.mat[1:10,]
?ggtess3Q
mapplot.i       <- tess3r::ggtess3Q(tess3r.qmat,coords.mat, interpolation.model = tess3r::FieldsKrigModel(10),resolution = c(500,500), col.palette = my.palette, window=c(x.min,x.max,y.min,y.max),background=TRUE,map.polygon=world_sp)
length(mapplot)
mapplot.i + ggplot2::theme_classic() + ggplot2::labs(title=paste0("Ancestry coefficients; K=",K), x="latitude", y="longitude") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) + current.gg.sf2 + ggplot2::geom_point(data = coords, ggplot2::aes(x = Lon, y = Lat), size = 1, shape = 21, fill = "black")
class(coords)
coords[1:10,]
colnames(coords[,1:2]) <- c("Lon","Lat")
coords.df <- coords#
			colnames(coords.df[,1:2]) <- c("Lon","Lat")
mapplot.i + ggplot2::theme_classic() + ggplot2::labs(title=paste0("Ancestry coefficients; K=",K), x="latitude", y="longitude") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) + current.gg.sf2 + ggplot2::geom_point(data = coords.df, ggplot2::aes(x = Lon, y = Lat), size = 1, shape = 21, fill = "black")
coords.df[1:10,]
coords.df[1:10,1:2]
colnames(coords.df[,1:2]) <- c("Lon","Lat")
coords.df[1:10,1:2]
names(coords.df)[1:2] <- c("Lon","Lat")
coords.df[1:10,1:2]
coords[1:10,]
coords.df <- coords#
			#colnames(coords.df[,1:2]) <- c("Lon","Lat")#
			names(coords.df)[1:2] <- c("Lon","Lat")
coords.df[1:10,]
mapplot[[i]]    <- mapplot.i + ggplot2::theme_classic() + ggplot2::labs(title=paste0("Ancestry coefficients; K=",K), x="latitude", y="longitude") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) + current.gg.sf2 + ggplot2::geom_point(data = coords.df, ggplot2::aes(x = Lon, y = Lat), size = 1, shape = 21, fill = "black")
plot(mapplot[[i]])
mapplot[[i]]    <- mapplot.i + ggplot2::theme_classic() + ggplot2::labs(title=paste0("Ancestry coefficients; K=",K), x="latitude", y="longitude") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) + current.gg.sf + ggplot2::geom_point(data = coords.df, ggplot2::aes(x = Lon, y = Lat), size = 1, shape = 21, fill = "black")
mapplot[[i]]
plot(mapplot[[i]])
i
if(!is.null(coords)){#
			my.palette      <- tess3r::CreatePalette(myCols[1:K], 9)#
			tess3r.qmat     <- suppressWarnings(tess3r::as.qmatrix(q.matrix))#
			#coords.mat      <- as.matrix(coords)#
			coords.mat      <- as.matrix(coords)[,1:2]#
			mapplot.i       <- tess3r::ggtess3Q(tess3r.qmat,coords.mat, interpolation.model = tess3r::FieldsKrigModel(10),resolution = c(500,500), col.palette = my.palette, window=c(x.min,x.max,y.min,y.max),background=TRUE,map.polygon=world_sp)#
			coords.df <- coords#
			#colnames(coords.df[,1:2]) <- c("Lon","Lat")#
			names(coords.df)[1:2] <- c("Lon","Lat")#
			message("Note to self: change the next line to use geom_sf and coord_sf instead of 'current.gg.sf'")#
		#	mapplot[[i]]    <- mapplot.i + ggplot2::theme_classic() + ggplot2::labs(title=paste0("Ancestry coefficients; K=",K), x="latitude", y="longitude") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) + current.gg.sf + ggplot2::geom_point(data = coords, ggplot2::aes(x = Lon, y = Lat), size = 1, shape = 21, fill = "black")#
			mapplot[[i]]    <- mapplot.i + ggplot2::theme_classic() + ggplot2::labs(title=paste0("Ancestry coefficients; K=",K), x="latitude", y="longitude") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) + current.gg.sf + ggplot2::geom_point(data = coords.df, ggplot2::aes(x = Lon, y = Lat), size = 1, shape = 21, fill = "black")#
			### Use coord_sf and geom_sf instead of #
			# ggplot2::coord_sf(xlim =,ylim = )#
			#mapplot[[i]]    <- mapplot.i + ggplot2::theme_classic() + ggplot2::labs(title=paste0("Ancestry coefficients; K=",K), x="latitude", y="longitude") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) + ggplot2::geom_point(data = coords, ggplot2::aes(x = Lon, y = Lat), size = 1, shape = 21, fill = "black")#
			### Edit this to#
		}#
		if(debug) message(cat("\r",paste0("K=",K," step 3.9")))
#dev.off()#
	if(debug) message("step 10.0")#
	### Defining the viewport size and creating lists of plots#
	vp                  <- grid::viewport(height=grid::unit(0.95,"npc"),width=grid::unit(0.95,"npc"))#
	#resultsA.grobs.list <- lapply(list(BICPlot, grp.plot2), FUN=ggplot2::ggplotGrob)#
	resultsA            <- lapply(X=lapply(list(BICPlot, grp.plot2), FUN=ggplot2::ggplotGrob), FUN=gridExtra::arrangeGrob, vp=vp)
if(!is.null(coords)){#
		resultsB <- lapply(X=lapply(c(admixturePlot, assignmentPlot,mapplot), FUN=ggplot2::ggplotGrob), FUN=gridExtra::arrangeGrob,vp=vp)#
	} else {#
		resultsB <- lapply(X=lapply(c(admixturePlot, assignmentPlot), FUN=ggplot2::ggplotGrob), FUN=gridExtra::arrangeGrob,vp=vp)#
	}
!is.null(coords)
mapplot
admixturePlot[[1]]
assignmentPlot[[1]]
resultsA            <- lapply(X=lapply(list(BICPlot, grp.plot2), FUN=ggplot2::ggplotGrob), FUN=gridExtra::arrangeGrob, vp=vp)
resultsB <- lapply(X=lapply(c(admixturePlot, assignmentPlot, mapplot), FUN=ggplot2::ggplotGrob), FUN=gridExtra::arrangeGrob,vp=vp)
test <- lapply(c(admixturePlot, assignmentPlot, mapplot), FUN=ggplot2::ggplotGrob)
test <- c(admixturePlot, assignmentPlot, mapplot)
length(test)
test
gg.plots.list <- c(admixturePlot, assignmentPlot, mapplot)
is.null(gg.plots.list)
lapply(gg.plots.list,is.null)
slapply(gg.plots.list,is.null)
sapply(gg.plots.list,is.null)
K
for(K in 2:max.clusters){#
		if(debug) message(paste0("K=",K," step 3.1"))#
		i=(K-1)#
		#dapc.pcabest.K      <- adegenet::dapc(genind, grp.mat[,i],n.pca=best.npca[i],n.da=5)#
		dapc.pcabest.K      <- dapc.list[[i]]#
		### Fewest number of individuals assigned to any cluster.#
		minsize.grp <- min(table(as.numeric(dapc.pcabest.K$assign)))#
		# switch density.stop to TRUE the first time minsize.grp is 1#
		if(!(minsize.grp > 1) & !density.stop){#
			density.stop <- TRUE#
		}#
		#if(!(minsize.grp < 4)){#
		#	ellipse.size <- 0#
		#} else {#
		#	ellipse.size <- 1.5#
		#}#
#		dapc.pcabest.list[[i]] <- dapc.pcabest.K#
#		posterior           <- dapc.pcabest.K$posterior#
#		q.matrix            <- posterior#
#		posterior           <- posterior.list[[i]]#
#		posterior.df        <- data.frame(indv=rep(rownames(posterior),ncol(posterior)), pop=rep(colnames(posterior),each=nrow(posterior)), assignment=c(posterior),K=K)#
		q.matrix            <- posterior.list[[i]]#
		posterior.df        <- q.df[q.df$K==K,]#
#		q.df[[i]]           <- posterior.df#
		##### ggplot scatterplots of discriminant functions#
		####
	#	scatterPlot.i       <- ggscatter.dapc(dapc.pcabest.K,col=myCols,legend=F,cstar=1,cpoint=4,label=T)#
	#	scatterPlot[[i]]    <- scatterPlot.i#
		#if(debug) message(cat("\r",paste0("K=",K," step 3.2")))#
		### density plots of discriminant functions#
		#if(!density.stop){#
		#	density.da.list.i <- list(); length(density.da.list.i) <- dapc.pcabest.K$n.da#
		#	for(z in 1:dapc.pcabest.K$n.da){#
		#		density.da.list.i[[z]] <- ggscatter.dapc(dapc.pcabest.K,xax=z,yax=z,col=myCols,legend=F,show.title=F,hideperimeter=T)#
		#	}#
		#} else {#
		#	density.da.list.i <- list(NULL)#
		#}#
		if(debug) message(cat("\r",paste0("K=",K," step 3.3")))#
		### biplots of discriminant functions#
		# Old versions#
	#	if(dapc.pcabest.K$n.da>1){#
	#		da.pairs.i        <- pset(x=1:dapc.pcabest.K$n.da,min.length=2,max.length=2)#
	#		da.pairs.mat.i    <- do.call(rbind,da.pairs.i)#
	#		da.psets[[i]]     <- da.pairs.mat.i#
	#		da.layout.mat.i   <- matrix(data=NA,nrow=max(da.pairs.mat.i[,1]),ncol=max(da.pairs.mat.i[,2]))#
	#		for(j in 1:length(da.pairs.i)){#
	#			da.layout.mat.i[da.pairs.mat.i[j,1],da.pairs.mat.i[j,2]] <- j#
	#		}#
	#		#da.layout.mat[[i]]  <- da.layout.mat.i[,c(2:ncol(da.layout.mat.i)),drop=F]#
	#		da.layout.mat.i    <- as.matrix(da.layout.mat.i)#
	#		da.layout.mat.i2   <- da.layout.mat.i[,c(2:ncol(da.layout.mat.i)),drop=FALSE]#
	#		da.layout.mat.i3   <- da.layout.mat.i2[1:nrow(da.layout.mat.i2),,drop=FALSE]#
	#		da.layout.mat[[i]] <- da.layout.mat.i3#
	#		biplots.da.list.i  <- list(); length(biplots.da.list.i) <- length(da.pairs.i)#
	#		for(z in 1:length(da.pairs.i)){#
	#			da.pairs.i.z <- da.pairs.i[[z]]#
	#			biplots.da.list.i[[z]] <- ggscatter.dapc(dapc.pcabest.K,xax=da.pairs.i.z[1],yax=da.pairs.i.z[2],col=myCols,legend=F,cstar=0,cellipse=0,cpoint=4,label=F,show.title=F,varname="DF",axis.title.cex=0.7,hideperimeter=T)#
	#		}#
	#	} else {#
	#		biplots.da.list.i  <- NULL#
	#		da.psets[[i]]      <- NULL#
	#		da.layout.mat[[i]] <- NULL#
	#	}#
		#if(debug) message(cat("\r",paste0("K=",K," step 3.4")))#
		##### ggplot density plots of principle components#
		#if(!density.stop){#
		#	density.pca.list.i <- list(); length(density.pca.list.i) <- dapc.pcabest.K$n.pca#
		#	for(z in 1:dapc.pcabest.K$n.pca){#
		#		density.pca.list.i[[z]] <- ggscatter.dapc(dapc.pcabest.K,vartype="pc",xax=z,yax=z,col=myCols,legend=F,show.title=F,hideperimeter=T)#
		#	}#
		#} else {#
		#	density.pca.list.i <- list(NULL)#
		#}#
		if(debug) message(cat("\r",paste0("K=",K," step 3.5")))#
		### ggplot biplots of principle components#
	#	if(dapc.pcabest.K$n.pca>1){#
	#		pca.pairs.i        <- pset(x=1:dapc.pcabest.K$n.pca,min.length=2,max.length=2)#
	#		pca.pairs.mat.i    <- do.call(rbind,pca.pairs.i)#
	#		pca.psets[[i]]     <- pca.pairs.mat.i#
	#		pca.layout.mat.i   <- matrix(data=NA,nrow=max(pca.pairs.mat.i[,1]),ncol=max(pca.pairs.mat.i[,2]))#
	#		for(j in 1:length(pca.pairs.i)){#
	#			pca.layout.mat.i[pca.pairs.mat.i[j,1],pca.pairs.mat.i[j,2]] <- j#
	#		}#
	#		pca.layout.mat.i    <- as.matrix(pca.layout.mat.i)#
	#		pca.layout.mat.i2   <- pca.layout.mat.i[,c(2:ncol(pca.layout.mat.i)),drop=FALSE]#
	#		pca.layout.mat.i3   <- pca.layout.mat.i2[1:nrow(pca.layout.mat.i2),,drop=FALSE]#
	#		pca.layout.mat[[i]] <- pca.layout.mat.i3#
	#		#pca.layout.mat[[i]] <- pca.layout.mat.i[,c(2:ncol(pca.layout.mat.i)),drop=F]#
	#		biplots.pca.list.i <- list(); length(biplots.pca.list.i) <- length(pca.pairs.i)#
	#		for(z in 1:length(pca.pairs.i)){#
	#			pca.pairs.i.z           <- pca.pairs.i[[z]]#
	#			biplots.pca.list.i[[z]] <- ggscatter.dapc(dapc.pcabest.K,vartype="pc",xax=pca.pairs.i.z[1],yax=pca.pairs.i.z[2],col=myCols,legend=F,cstar=0,cellipse=0,cpoint=4,label=F,show.title=F,varname="PC",axis.title.cex=0.7,hideperimeter=T)#
	#		}#
	#	} else {#
	#		biplots.pca.list.i  <- NULL#
	#		pca.psets[[i]]      <- NULL#
	#		pca.layout.mat[[i]] <- NULL#
	#	}#
	#	if(debug) message(cat("\r",paste0("K=",K," step 3.6")))#
		posterior.gg        <- ggplot2::ggplot(posterior.df, ggplot2::aes(fill= pop, x= assignment, y=indv)) + ggplot2::geom_bar(position="stack", stat="identity") + ggplot2::theme_classic() + ggplot2::theme(axis.text.y = ggplot2::element_text(size = label.size), panel.grid.major = ggplot2::element_blank(), panel.grid.minor = ggplot2::element_blank(), panel.background = ggplot2::element_blank()) + ggplot2::labs(x = "Membership Probability",y="",fill="Cluster",title=paste0("K = ",K,"; PCs retained = ",best.npca[i])) + ggplot2::scale_fill_manual(values=myCols[1:K])#
		admixturePlot[[i]]  <- posterior.gg#
		#indv.KmaxPosterior <- apply(X=q.matrix, MARGIN=1, FUN=function(x){which(x==max(x))})#
		if(debug) message(cat("\r",paste0("K=",K," step 3.7")))#
		indv.maxPosterior  <- apply(X=q.matrix, MARGIN=1, FUN=function(x){max(x)})#
		labels             <- rep("",nrow(posterior.df))#
		labels[posterior.df[,"assignment"] %in% indv.maxPosterior] <- "+"#
		assignment.K        <- ggplot2::ggplot(data=posterior.df, ggplot2::aes(x= pop, y=indv,fill=assignment)) + ggplot2::geom_tile(color="gray") + ggplot2::theme_classic() + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5), axis.text.y = ggplot2::element_text(size = label.size), panel.grid.major = ggplot2::element_blank(), panel.grid.minor = ggplot2::element_blank(), panel.background = ggplot2::element_blank(), legend.position = "none", ) + ggplot2::labs(title = paste0("K = ",K,"; PCs retained = ", best.npca[i]), x="Clusters", y="") + ggplot2::scale_fill_gradient2(low = "white", mid = "yellow", high = "red", midpoint = 0.5) + ggplot2::geom_text(label=labels)#
		assignmentPlot[[i]] <- assignment.K#
		if(debug) message(cat("\r",paste0("K=",K," step 3.8")))#
		# if(debug) message(cat("\r",paste0("smallest cluster has ",minsize.grp," individuals")))#
		if(!is.null(coords)){#
			my.palette      <- tess3r::CreatePalette(myCols[1:K], 9)#
			tess3r.qmat     <- suppressWarnings(tess3r::as.qmatrix(q.matrix))#
			#coords.mat      <- as.matrix(coords)#
			coords.mat      <- as.matrix(coords)[,1:2]#
			mapplot.i       <- tess3r::ggtess3Q(tess3r.qmat,coords.mat, interpolation.model = tess3r::FieldsKrigModel(10),resolution = c(500,500), col.palette = my.palette, window=c(x.min,x.max,y.min,y.max),background=TRUE,map.polygon=world_sp)#
			coords.df <- coords#
			#colnames(coords.df[,1:2]) <- c("Lon","Lat")#
			names(coords.df)[1:2] <- c("Lon","Lat")#
		#	message("Note to self: change the next line to use geom_sf and coord_sf instead of 'current.gg.sf'")#
		#	mapplot[[i]]    <- mapplot.i + ggplot2::theme_classic() + ggplot2::labs(title=paste0("Ancestry coefficients; K=",K), x="latitude", y="longitude") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) + current.gg.sf + ggplot2::geom_point(data = coords, ggplot2::aes(x = Lon, y = Lat), size = 1, shape = 21, fill = "black")#
			mapplot[[i]]    <- mapplot.i + ggplot2::theme_classic() + ggplot2::labs(title=paste0("Ancestry coefficients; K=",K), x="latitude", y="longitude") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) + current.gg.sf + ggplot2::geom_point(data = coords.df, ggplot2::aes(x = Lon, y = Lat), size = 1, shape = 21, fill = "black")#
			### Use coord_sf and geom_sf instead of #
			# ggplot2::coord_sf(xlim =,ylim = )#
			#mapplot[[i]]    <- mapplot.i + ggplot2::theme_classic() + ggplot2::labs(title=paste0("Ancestry coefficients; K=",K), x="latitude", y="longitude") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) + ggplot2::geom_point(data = coords, ggplot2::aes(x = Lon, y = Lat), size = 1, shape = 21, fill = "black")#
			### Edit this to#
		}#
		if(debug) message(cat("\r",paste0("K=",K," step 3.9")))#
		#da.densityPlot[[i]]  <- density.da.list.i#
		#da.biPlot[[i]]       <- biplots.da.list.i#
		#pca.densityPlot[[i]] <- density.pca.list.i#
		#pca.biPlot[[i]]      <- biplots.pca.list.i#
	} ### END OF LOOP#
	### Plots of DF or PC density for each given K
if(debug) message("step 10.0")#
	### Defining the viewport size and creating lists of plots#
	vp                  <- grid::viewport(height=grid::unit(0.95,"npc"),width=grid::unit(0.95,"npc"))#
	#resultsA.grobs.list <- lapply(list(BICPlot, grp.plot2), FUN=ggplot2::ggplotGrob)#
	resultsA            <- lapply(X=lapply(list(BICPlot, grp.plot2), FUN=ggplot2::ggplotGrob), FUN=gridExtra::arrangeGrob, vp=vp)#
	if(!is.null(coords)){#
		gg.plots.list0 <- c(admixturePlot, assignmentPlot, mapplot)#
		gg.plots.list  <- gg.plots.list0[!sapply(gg.plots.list,is.null)]#
		resultsB       <- lapply(X= lapply(c(admixturePlot, assignmentPlot, mapplot), FUN=ggplot2::ggplotGrob), FUN=gridExtra::arrangeGrob,vp=vp)#
	} else {#
		resultsB <- lapply(X=lapply(c(admixturePlot, assignmentPlot), FUN=ggplot2::ggplotGrob), FUN=gridExtra::arrangeGrob,vp=vp)#
	}
results1   <- c(resultsA, resultsB)
".pdf" %in% include.out
if(".pdf" %in% include.out){#
		pdf(height=6,width=10,file=save.as,onefile=TRUE)#
		for(i in 1:length(results1)){#
			grid::grid.draw(results1[[i]])#
			if(i < length(results1)){#
				grid::grid.newpage()#
			}#
		}#
		dev.off()#
		### Save the PC and DF density and biplots to a separate PDF, with height and width determined by number of rows and columns of plots.#
		if(FALSE){#
			res2.save.as <- paste0(tools::file_path_sans_ext(save.as),"_plots2.pdf")#
			pdf(height=res2.height,width=res2.width,file=res2.save.as, onefile=TRUE)#
			for(i in 1:length(dapc.componentPlots)){#
				grid::grid.draw(dapc.componentPlots[[i]])#
				if(i < length(dapc.componentPlots)){#
					grid::grid.newpage()#
				}#
			}#
			dev.off()#
		}#
	}
getwd()
setwd("Documents/misc.wrappers")
devtools::document()
devtools::document()
devtools::document()
q("no")
