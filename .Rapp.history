spdf_world_10             <- rnaturalearth::ne_countries(scale=10)
spTransform(spdf_world_10)
spTransform(crs(spdf_world_10))
crs(spdf_world_10)
spTransform(proj4string(spdf_world_10))
spTransform(crs(proj4string(spdf_world_10)))
spTransform(spdf_world_10,proj4string(spdf_world_10))
test <- spTransform(spdf_world_10,proj4string(spdf_world_10))
## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	### Define CRS using wkt format
test <- spTransform(spdf_world_10,crs.string)
wkt(spdf_world_10)
wkt(spdf_world_10) <- crs.string
spdf_world_10             <- rnaturalearth::ne_countries(scale=10)
wkt(spdf_world_10)
?CRS()
CRS(spdf_world_10)
spdf_world_10             <- rnaturalearth::ne_countries(scale=10)
CRS(spdf_world_10)
crs(spdf_world_10)
"+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"
crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"
raster::crs(spdf_world_10)   <- crs.string
class(spdf_world_10)
class(rnaturalearth::ne_countries(scale=10))
crs(spdf_world_10)
update.packages("sp")
CRS(4326)
CRS("4326")
CRS("EPSG:4326")
crs(spdf_world_10) <- "+init=EPSG:4326"
crs(spdf_world_10)
spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string
points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}
sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]
crs(sp_unique.polygons.at.circles)
coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))
if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==3){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}
alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1
hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))
crs(hull.alpha.polygon)
raster::crs(hull.alpha.polygon) <- crs.string
crs(hull.alpha.polygon)
buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))
alpha
crs(buffer.poly)
plot(buffer.poly)
outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))
plot(outer.poly,add=T,border="red")
raster::crs(outer.poly)
plot(points.sp,add=T,pch=20)
alpha <- 2
hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Set CRS of hull.alpha.polygon#
			raster::crs(hull.alpha.polygon) <- crs.string#
			#buffer.poly0       <- rgeos::gBuffer(hull.alpha.polygon,width=0)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: this may generate a warning while alpha is large enough that some polygon points fall off the global map. This is okay though, because alpha will be refined.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))
CRS(buffer.poly)
proj4string(buffer.poly)
proj4string(spdf_world_10)
crs(buffer.poly)
showWKT(crs(buffer.poly))
rgdal::showWKT(sp::proj4string(crs.string))
rgdal::showWKT(crs.string)
?CRS()
?geosphere::destPoint()
hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))
crs(hull.alpha.polygon)
buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))
library(devtools)
devtools::install_github("valentinitnelav/geobuffer")
library(geobuffer)
?geobuffer()
?geobuffer_pts()
test <- geobuffer_pts(hull.alpha.sp,width=10000)
test <- geobuffer_pts(xy=hull.alpha.sp,dist_m=10000)
crs(hull.alpha.sp)
projects.alpha.points <- hull.alpha.sp; crs(projects.alpha.points) <- crs.string
test <- geobuffer_pts(xy=projects.alpha.points,dist_m=10000)
projected.alpha.points <- hull.alpha.sp; crs(projected.alpha.points) <- crs.string#
			geodessic.buffered.points <- geobuffer_pts(xy=projected.alpha.points,dist_m=10000)#
			geodessic.buffered.poly <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(geodessic.buffered.points)),ID="geo.buff.pts")))
buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))
plot(geodessic.buffered.poly)
alpha
plot(buffer.poly)
alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.
alpha=1
hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Set CRS of hull.alpha.polygon. Note:#
			# raster::crs(hull.alpha.polygon) <- crs.string#
			### testing the geobuffer package#
			projected.alpha.points <- hull.alpha.sp; crs(projected.alpha.points) <- crs.string#
			geodessic.buffered.points <- geobuffer_pts(xy=projected.alpha.points,dist_m=10000)#
			geodessic.buffered.poly <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(geodessic.buffered.points)),ID="geo.buff.pts")))#
			#buffer.poly0       <- rgeos::gBuffer(hull.alpha.polygon,width=0)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon, yet, because gBuffer works in Euclidean space#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.
plot(geodessic.buffered.poly)
plot(buffer.poly,border="red")
plot(geodessic.buffered.poly)
plot(buffer.poly,border="red",add=T)
plot(points.sp,pch=20,add=T)
hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Set CRS of hull.alpha.polygon. Note:#
			# raster::crs(hull.alpha.polygon) <- crs.string#
			### testing the geobuffer package#
			# projected.alpha.points <- hull.alpha.sp; crs(projected.alpha.points) <- crs.string#
			# geodessic.buffered.points <- geobuffer_pts(xy=projected.alpha.points,dist_m=10000)#
			# geodessic.buffered.poly <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(geodessic.buffered.points)),ID="geo.buff.pts")))#
			#buffer.poly0       <- rgeos::gBuffer(hull.alpha.polygon,width=0)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon, yet, because gBuffer works in Euclidean space#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))
alpha
plot(outer.poly)
coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==3){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Set CRS of hull.alpha.polygon. Note:#
			# raster::crs(hull.alpha.polygon) <- crs.string#
			### testing the geobuffer package#
			# projected.alpha.points <- hull.alpha.sp; crs(projected.alpha.points) <- crs.string#
			# geodessic.buffered.points <- geobuffer_pts(xy=projected.alpha.points,dist_m=10000)#
			# geodessic.buffered.poly <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(geodessic.buffered.points)),ID="geo.buff.pts")))#
			#buffer.poly0       <- rgeos::gBuffer(hull.alpha.polygon,width=0)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon, yet, because gBuffer works in Euclidean space#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Set CRS of outer.poly#
			# raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon (previous used this function on hull.alpha.polygon#
			test.simple        <- rgeos::gIsSimple(outer.poly)#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}
crs(outer.poly)
coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==3){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Set CRS of hull.alpha.polygon. Note:#
			# raster::crs(hull.alpha.polygon) <- crs.string#
			### testing the geobuffer package#
			# projected.alpha.points <- hull.alpha.sp; crs(projected.alpha.points) <- crs.string#
			# geodessic.buffered.points <- geobuffer_pts(xy=projected.alpha.points,dist_m=10000)#
			# geodessic.buffered.poly <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(geodessic.buffered.points)),ID="geo.buff.pts")))#
			#buffer.poly0       <- rgeos::gBuffer(hull.alpha.polygon,width=0)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon, yet, because gBuffer works in Euclidean space#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Set CRS of outer.poly#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon (previous used this function on hull.alpha.polygon#
			test.simple        <- rgeos::gIsSimple(outer.poly)#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}
plot(outer.poly)
plot(points.sp,pch=20,col="red",add=T)
fractal.dimension  <- fracD(outer.poly)
fractal.dimension
fractal.dimension  <- fracD(outer.poly)#
		alpha      <- alpha.i#
		while(fractal.dimension > 1.1){#
			alpha      <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}
plot(outer.poly)
plot(points.sp,add="red")
plot(points.sp,add=T,pch=20)
raster::crs(outer.poly) <- crs.string
polygons.mcp <- adehabitatHR::mcp(points.sp,percent=100)
crs(points.sp)
crs(polygons.mcp)
CRS(polygons.mcp)
outer.projected              <- unname(sp2coords(outer.poly))
outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))
outer              <- unname(sp2coords(outer.poly))
outer[1:10,]
outer.projected[1:10,]
all(outer.projected==outer)
coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==3){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon.#
			test.simple        <- rgeos::gIsSimple(outer.poly)#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > 1.1){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string
outer              <- unname(sp2coords(outer.poly))
nrow(outer)
outer[1,]
outer[39,]
outer.poly
# required packages#
library(sp)                 ### Used for everything#
library(maps)               ### map.axes function#
library(rgeos)              ### gBuffer and gArea function#
library(rgdal)              ### showWKT function#
library(raster)             ### crs and bind function#
library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
library(sampSurf)           ### spCircle function#
library(geosphere)          ### perimeter and areaPolygon functions#
# library(geobuffer)        ### geobuffer_pts  ### install using: devtools::install_github("valentinitnelav/geobuffer"); not going to use this.#
library(alphahull)          ### ahull function#
library(adehabitatHR)       ### function to generate minimum convex polygon#
library(rnaturalearth)      ### Global geographic vectors#
library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
devtools::install_github("valentinitnelav/geobuffer")#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.05#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon.#
			test.simple        <- rgeos::gIsSimple(outer.poly)#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.05)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
			#plot(sp_unique.polygons.at.circles,add=T,col="gray90")#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord")
# required packages#
library(sp)                 ### Used for everything#
library(maps)               ### map.axes function#
library(rgeos)              ### gBuffer and gArea function#
library(rgdal)              ### showWKT function#
library(raster)             ### crs and bind function#
library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
library(sampSurf)           ### spCircle function#
library(geosphere)          ### perimeter and areaPolygon functions#
# library(geobuffer)        ### geobuffer_pts  ### install using: devtools::install_github("valentinitnelav/geobuffer"); not going to use this.#
library(alphahull)          ### ahull function#
library(adehabitatHR)       ### function to generate minimum convex polygon#
library(rnaturalearth)      ### Global geographic vectors#
library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
devtools::install_github("valentinitnelav/geobuffer")#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon.#
			test.simple        <- rgeos::gIsSimple(outer.poly)#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
			#plot(sp_unique.polygons.at.circles,add=T,col="gray90")#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord")
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=1.09)
class(test[[2]])
fracD(test2)
fracD(test)
fracD(test[[2]])
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=1.11)
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=1.12)
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=1.5)
fracD(test[[2]])
coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord";buffer.adj=0;coords.radius=0.01;method=3;plot.outer=T;counter.clockwise=T;output.path=NULL;max.fractal.dimension=1.5
# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}
input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]
method=1
coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))
if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1
((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)
while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon.#
			test.simple        <- rgeos::gIsSimple(outer.poly)#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}
fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i
fractal.dimension
alpha
plot(outer.poly)
test.simple
rgeos::gIsValid(outer.poly)
outer.poly
nrow(sp2coords(outer.poly))
nrow(unique(sp2coords(outer.poly)))
rgeos::gIsRing(outer.poly)
test.simple        <- all(c(rgeos::gIsSimple(outer.poly),rgeos::gIsRing(outer.poly)))
test.simple
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon.#
			test.SimpleRing        <- all(c(rgeos::gIsSimple(outer.poly),rgeos::gIsRing(outer.poly)))#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			if(test.SimpleRing & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
			#plot(sp_unique.polygons.at.circles,add=T,col="gray90")#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=1.5)
sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]
coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.
alpha <- 2
hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon.#
			test.SimpleRing        <- all(c(rgeos::gIsSimple(outer.poly),rgeos::gIsRing(outer.poly)))#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			if(test.SimpleRing & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)
test.SimpleRing
gIsEmpty(outer.poly)
geosphere::areaPolygon(outer.poly)
geosphere::areaPolygon(buffer.poly)
buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))
outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))
geosphere::areaPolygon(outer.poly) == geosphere::areaPolygon(gBuffer(outer.poly,width=0))
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Run this test before switching back to Euclidean space#
			### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon.#
			test.simple        <- rgeos::gIsSimple(outer.poly)#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
			#plot(sp_unique.polygons.at.circles,add=T,col="gray90")#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=1.5)
plot(test[[2]],add=T,border="green")
coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord";buffer.adj=0;coords.radius=0.01;method=3;plot.outer=T;counter.clockwise=T;output.path=NULL;max.fractal.dimension=1.5
sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]
coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.
while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Run this test before switching back to Euclidean space#
			### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon.#
			test.simple        <- rgeos::gIsSimple(outer.poly)#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}
fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i
fractal.dimension
alpha
plot(outer.poly,add=T,border="red")
plot(buffer.poly,add=T,border="blue")
plot(hull.alpha.polygon,add=T,border="red")
geosphere::areaPolygon(outer.poly) == geosphere::areaPolygon(gBuffer(outer.poly,width=0))
alpha
alpha.i
alpha.upper
alpha.lower
median(c(alpha.lower,alpha.upper))
alpha.i
alpha
hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))
buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))
outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))
geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))
gIsSimple(hull.alpha.polygon)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Test hull.alpha.polygon is simple#
			# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Run this test before switching back to Euclidean space#
			### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon.#
			test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
			#plot(sp_unique.polygons.at.circles,add=T,col="gray90")#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=1.5)
coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord";buffer.adj=0;coords.radius=0.01;method=3;plot.outer=T;counter.clockwise=T;output.path=NULL;max.fractal.dimension=1.5
sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]
coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			### Test hull.alpha.polygon is simple#
			# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			### Run this test before switching back to Euclidean space#
			### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
			raster::crs(outer.poly) <- crs.string#
			### Test that the output coordinates define a simple polygon.#
			test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
			### Test if all of the input points are in the output polygon#
			test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}
plot(hull.alpha.polygon,add=T,border="red")
rgeos::gIsSimple(hull.alpha.polygon)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
				if(test.simple & test.coverage){#
					alpha.upper <- min(alpha.upper,alpha)#
				} else {#
					alpha.lower <- max(alpha.lower,alpha)#
				}#
				### save a copy of the current alpha value to initialize the next while loop#
				alpha.i <- alpha#
				alpha   <- median(c(alpha.lower,alpha.upper))#
				i=(i+1)#
			} else {#
				test.simple <- FALSE#
			}#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
			#plot(sp_unique.polygons.at.circles,add=T,col="gray90")#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=1.5)
while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
			#plot(sp_unique.polygons.at.circles,add=T,col="gray90")#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=1.5)
fracD(test[[2]])
mtext(paste0("perimeter-area fractal dimension: ",fractal.dimension),adj=0.1,line=1.25,cex=0.8)
mtext(paste0("P/A fractal dimension = ",round(fractal.dimension,digits=3)),adj=0.1,line=1.25,cex=0.8)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
			#plot(sp_unique.polygons.at.circles,add=T,col="gray90")#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			mtext(paste0("P/A fractal dimension = ",round(fractal.dimension,digits=3)),adj=0.1,line=1.25,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=2)
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/leporinum.coord",max.fractal.dimension=2,method=2)
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=1,max.fractal.dimension=1.2)
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.2)
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.1)
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=1,max.fractal.dimension=1.1)
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=1,max.fractal.dimension=1.105)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.1,line=1.25,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.25,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=1,max.fractal.dimension=1.105)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.1,line=1.25,cex=0.8,pos=3)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.25,cex=0.8,pos=3)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
?mtext
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.1,line=1.25,cex=0.8,padj=1)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.25,cex=0.8,padj=1)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.1,line=1.25,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.25,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			text("+ = coordinates written to output.path (if set)",col="green",adj=0.1,line=1.25,cex=0.8,pos=3)#
			text(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.25,cex=0.8,pos=3)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
?text()
??text()
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.1,line=1.5,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.5,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.12,line=1.5,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.5,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.0.75,line=1.5,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.5,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.75,line=1.5,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.5,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.15,line=1.5,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.5,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.3,line=1.5,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.5,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0.1,line=1.5,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.5,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0,line=1.5,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0.1,line=0.5,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
# required packages#
# library(sp)                 ### Used for everything#
# library(maps)               ### map.axes function#
# library(rgeos)              ### gBuffer and gArea function#
# library(rgdal)              ### showWKT function#
# library(raster)             ### crs and bind function#
# library(smoothr)            ### densify function for adding outer points by interpolating along perimeter#
# library(sampSurf)           ### spCircle function#
# library(geosphere)          ### perimeter and areaPolygon functions#
# library(alphahull)          ### ahull function#
# library(adehabitatHR)       ### function to generate minimum convex polygon#
# library(rnaturalearth)      ### Global geographic vectors#
# library(rnaturalearthhires) ### high resolution data for rnaturalearth package#
#
#' @param coords Two column numeric matrix containing longitude and latitude of the samples in decimal degree format, or a character string with path to the input .coords file used for eems; the input file must be space separated and without a header.#
#' @param alpha Value of alpha parameter (Default is 1). Increase alpha incrementally by about 0.1 until the polygon plot corresponding to the outer coordinates is simple polygon (as opposed to a complex, self-intersecting polygon).#
#' @param buffer.adj This argument is not yet implemented. A number between 0 and 1 that determines the size of the buffer region surrounding the points supplied by coords.#
#' @param method A number (1, 2, or 3) determining how the output coordinates will be generated.#
#' If method=1 (the default) produces a potentially more useful result, and uses the alpha hull of geographic regions that intersect with input coordinates. This method may be slow if input coordinates include large sampling gaps. In such cases increases the value of alpha.start.#
#' If method=2 is similar to method 1, except that the output coordinates are only determined from the input coordinates (and buffer setting), rather than from the regions of the base map (political geography from natural earth dataset) that intersect the input coordinates. Either method should be fine for EEMS, but method 1 tends to look nicer.#
#' If method=3 is fast and uses the minimum convex polygon of input coodinates as a starting point.#
#' @param coords.radius Number specifying the radius (in degrees) to use around input coordinates when determining spatial intersections. Increasing the value of this parameter can be useful if coordinates are located offshore of regions outlined in basemaps (high resolution Natural Earth dataset).#
#' @param max.fractal.dimension Value between 1 and 2 contolling the shape complexity of the polygon with the output coordinates. Values near 1 have low complexity (e.g., circles, squares), and shape complexity increases as max.fractal.dimension approaches 2. The default value 1.1 seems to work well for most cases. Ignored if method=3.#
#' @param plot.outer Logical indicating if the points defining the output ".outer" table should be plotted in green, as well as the ".coords" (coords) points in black.#
#' @param counter.clockwise Should the output cooordinates be ordered counterclockwise. Default is TRUE and is the required format for EEMS.#
#' @param output.path Character string with path where to save coordinates. Default is NULL.#
#' @result A two column numerical matrix containing the longitude and latitude of the output polygon. The matrix written to output.path can be used as the ".outer" polygon used by EEMS. A map is plotted to visualize the results.#
create.outer <- function(coords,method=1,buffer.adj=0,coords.radius=0.01,max.fractal.dimension=1.1,plot.outer=T,counter.clockwise=T,output.path=NULL){#
	# Function to extract the coordinates matrix (numeric mode) from a class Polygon, Polygons, SpatialPolygons, or SpatialPolygonsDataFrame object that containins a single polygon.#
	# Do not use this function if the inout spatial object contains more than coordinates matrix.#
	sp2coords <- function(x){#
		if(is(x,"SpatialPolygonsDataFrame") | is(x,"SpatialPolygons")){#
			result <- x@polygons[[1]]@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygons")){#
			result <- x@Polygons[[1]]@coords#
		}#
		if(is(x,"Polygon") | is(x,"SpatialPoints")){#
			result <- x@coords#
		}#
		unname(result)#
	}#
	### Convert a coordinates matrix into a SpatialPolygons object in circles centered at input coordinates, and radius specified by r#
	coords2sp.poly <- function(coords.mat,r=0.01){#
		colnames(coords.mat) <- c("x","y")#
		circles.list <- apply(X=coords.mat,MARGIN=1,FUN=function(x){sampSurf::spCircle(radius=r,centerPoint=x)[[1]]})#
		res          <- do.call(raster::bind,circles.list)#
		res#
	}#
	### Fractal dimension of perimeter-area relationship, a metric of polygon complexity with values from 1 (simple euclidean shapes likes squares and circles) tp approaching 2 for increasingly complex polygons.#
	# More info: http://www.umass.edu/landeco/teaching/landscape_ecology/schedule/chapter9_metrics.pdf#
	# Input must be a SpatialPolygons object#
	fracD <- function(x){#
		# area in meters squared#
		x.area      <- geosphere::areaPolygon(x)#
		# perimeter in meters#
		x.perimeter <- geosphere::perimeter(x)#
		(2*log10(x.perimeter))/(log10(x.area))#
	}#
	#### For a SpatialPolygonsDataFrame, extract the lowest-level polygons and hold each as a feature in a SpatialPolygons object.#
	extract.base.polygons <- function(spdf){#
		for(i in 1:nrow(spdf)){#
			sp.temp <- spdf@polygons[[i]]#
			for(j in 1:length(sp.temp@Polygons)){#
				id.temp <- paste0(i,".",j)#
				polygons.ij <- sp::SpatialPolygons(list(sp::Polygons(list(sp.temp@Polygons[[j]]),ID=id.temp)))#
				if(i==1 & j==1){#
					polygons.all <- polygons.ij#
				} else {#
					polygons.all <- raster::bind(polygons.all,polygons.ij)#
				}#
			}#
		}#
		### Preserve crs definition#
		raster::crs(polygons.all) <- raster::crs(spdf)#
		### object returned#
		polygons.all#
	}#
	input.coords <- coords#
	### Check which type of object is being supplied to coords and define coords accordingly#
	if(is(input.coords,"character")){#
		coords   <- data.matrix(read.table(input.coords,header=F))#
	}#
	if(is(input.coords,"matrix") | is(input.coords,"data.frame")){#
		coords       <- data.matrix(input.coords)#
		mode(coords) <- "numeric"#
	}#
	## High resolution global map of political regions.#
	spdf_world_10             <- rnaturalearth::ne_countries(scale=10)#
	## Character string defining the Coordinate Reference System (CRS) in WKT format#
	# crs.string <- rgdal::showWKT(sp::proj4string(spdf_world_10))#
	# crs.string <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"#
	crs.string <- "+init=EPSG:4326"#
	wkt.string <- rgdal::showWKT(crs.string)#
	### Define CRS using wkt format#
	raster::crs(spdf_world_10)   <- crs.string#
	### SpatialPoints object holding coords#
	points.sp <- sp::SpatialPoints(coords)#
	raster::crs(points.sp) <- crs.string#
	### SpatialPolygons object holding circles with centerpoints at coords#
	circles.poly <- coords2sp.poly(coords.mat=coords,r=coords.radius)#
	raster::crs(circles.poly) <- crs.string#
	### Spatial data frame for the map features that intersect with the input coords#
	unique.features.at.circles <- do.call(rbind,unique(sp::over(circles.poly, spdf_world_10,returnList=T)))#
	### spdf row indices for the unique regions in unique.features.at.circles#
	indices_unique.features.at.circles <- which(spdf_world_10$sov_a3 %in% unique(unique.features.at.circles$sov_a3))#
	### Corresponding SpatialPolygonsDateFrame object#
	spdf_unique.features.at.circles <- spdf_world_10[indices_unique.features.at.circles,]#
	### Restructuring the heirarchy of lowest-level polygons, treating them as separate features of one SpatialPolygons object.#
	## The purpose of this is to be able to use sp::over() to search for polygons that intersect with coords.#
	base.polygons.sp <- extract.base.polygons(spdf_unique.features.at.circles)#
	### Get the feature indices for the polygons that intersect with circles representing input coordinates#
	indices_polygons.at.circles <- sp::over(circles.poly,base.polygons.sp)#
	### Check if any NA values in indices_unique.polygons.at.circles, which occurs when one more of the input circles does not intersect any polygons (i.e. they fall in the ocean).#
	### If NAs exist, try increasing the value of r parameter of coords2sp.poly function.#
	if(any(is.na(indices_polygons.at.circles))){#
		problem.points <- unname(which(is.na(indices_polygons.at.circles)))#
		stop(paste0("sample(s) coords[",paste(problem.points,collapse=" "),",]  does not intersect map. Try increasing coords.radius or remove sample(s) from input"))#
	}#
	### Extract polygons in base.polygons.sp that intersect circles.poly#
	sp_unique.polygons.at.circles      <- base.polygons.sp[unique(indices_polygons.at.circles)]#
	sp_unique.polygons.without.circles <- base.polygons.sp[-unique(indices_polygons.at.circles)]#
	if(method %in% c(1,2)){#
		#### Method 1 for getting maps.coords.list#
		### Two column numerical matrix of the coordinates of polygons that intersect input points#
		coords.polygons.with.points <- unique(round(do.call(rbind,lapply(X=1:length(sp_unique.polygons.at.circles),FUN=function(x){sp2coords(sp::polygons(sp_unique.polygons.at.circles)[x])})),digits=3))#
		####
		if(method==1){#
			coords.for.alphahull <- coords.polygons.with.points#
			#buffer.width <- ((-0.75)+buffer.adj)#
		}#
		if(method==2){#
			coords.for.alphahull <- unique(coords)#
			#buffer.width <- buffer.adj#
		}#
		### initiallizing the while loop#
		alpha.lower <- 1#
		alpha.upper <- 50#
		i=1; areas.equal <- FALSE; alpha <- alpha.upper; alpha.tol <- 0.1#
		### Run while loop to find a low value of alpha that also generates a simple polygon (not self-intersecting or filled with holes) when input coordinates are supplied to ahull.#
		# A polygon is considered simple if supplying the ahull polygon to gBuffer with buffer.width=0 produces a polygon with the same area as the input polygon. This works because gBuffer produces simple polygons even if the result clips the input polygon.#
		while(((alpha.upper-alpha.lower)>alpha.tol) & (i < 100)){#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			if(rgeos::gIsSimple(hull.alpha.polygon)){#
				### Test hull.alpha.polygon is simple#
				# geosphere::areaPolygon(hull.alpha.polygon) == geosphere::areaPolygon(gBuffer(hull.alpha.polygon,width=0))#
				### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
				# Note: Do not set the crs of hull.alpha.polygon because gBuffer function would introduce distortions associated with the projection. In reality this might not be be a big deal but I'm not sure.#
				buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
				### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
				outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
				### Run this test before switching back to Euclidean space#
				### Set CRS of outer.poly (now we are back in Euclidean space); this must be done before using function sp::over()#
				raster::crs(outer.poly) <- crs.string#
				### Test that the output coordinates define a simple polygon.#
				test.simple        <- all(c(rgeos::gIsSimple(outer.poly), rgeos::gIsSimple(hull.alpha.polygon)))#
				### Test if all of the input points are in the output polygon#
				test.coverage      <- (!any(is.na(sp::over(points.sp,outer.poly))))#
			} else {#
				test.simple   <- FALSE#
				test.coverage <- FALSE#
			}#
			if(test.simple & test.coverage){#
				alpha.upper <- min(alpha.upper,alpha)#
			} else {#
				alpha.lower <- max(alpha.lower,alpha)#
			}#
			### save a copy of the current alpha value to initialize the next while loop#
			alpha.i <- alpha#
			alpha   <- median(c(alpha.lower,alpha.upper))#
			i=(i+1)#
		}#
		fractal.dimension  <- fracD(outer.poly)#
		alpha          <- alpha.i#
		while(fractal.dimension > max.fractal.dimension){#
			alpha              <- (alpha+0.1)#
			hull.alpha         <- alphahull::ahull(coords.for.alphahull,alpha=alpha)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=((-0.75)+buffer.adj))#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			fractal.dimension  <- fracD(outer.poly)#
		}#
		raster::crs(outer.poly) <- crs.string#
	} else {#
		if(method==3){#
			### Minimum convex polygon that contains the maps with points.#
			polygons.mcp <- suppressWarnings(adehabitatHR::mcp(points.sp,percent=100))#
			mcp.coords   <- unique(sp2coords(polygons.mcp))#
			### Generate the alpha-hull of the polygons with points#
			hull.alpha         <- alphahull::ahull(mcp.coords,alpha=1)#
			hull.alpha.coords  <- rbind(hull.alpha$arcs[,1:2],hull.alpha$arcs[1,1:2])#
			hull.alpha.sp      <- sp::SpatialPoints(hull.alpha.coords)#
			hull.alpha.polygon <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(hull.alpha.sp)),ID="alpha.hull")))#
			buffer.width       <- (0.5+buffer.adj)#
			### Create a polygon encompassing hull.alpha.polygon, with size determined by the value of buffer.width#
			buffer.poly        <- rgeos::gBuffer(hull.alpha.polygon,width=buffer.width)#
			### Same as buffer.poly except points are added at midpoints of edges longer than max_distance; process repeated until all edges less than. This can make it easier to visualize the border of the output polygon, but otherwise this isnt useful.#
			outer.poly         <- smoothr::densify(buffer.poly,max_distance=(0.25*alpha))#
			raster::crs(outer.poly) <- crs.string#
		} else {#
			stop("set method to 1, 2, or 3")#
		}#
	}#
	outer     <- unname(sp2coords(outer.poly))#
	if(counter.clockwise){#
		outer <- cbind(rev(outer[,1]),rev(outer[,2]))#
	}#
	### Show the relationship between the outer coordinates, the input coordinates, and geographic regions#
	if(plot.outer){#
		### Turns off current graphics devices before plotting. This seems to help prevent the new plots from inheriting graphical parameters from the current device.#
		if(!is.null(dev.list())){#
			dev.off()#
		}#
		### Plots in slightly different ways depending depending on the method used.#
		if(method %in% c(1,2)){#
			### Plot the outer coordinates in white to define the extent#
			plot(sp::SpatialPoints(outer),col="white")#
			#plot(submaps.with.points.sp,add=T,col="gray90")#
			plot(spdf_world_10,add=T)#
			if(method==1){#
			### Add a layer containing the regions of the basemap that include at least one point (regions in gray)#
				plot(spdf_unique.features.at.circles,add=T,col="gray90")#
				plot(sp_unique.polygons.without.circles,add=T,col="white")#
			}#
			### Add green crosshairs for output coordinates (the outer file for eems)#
			plot(sp::SpatialPoints(outer),col="green",add=T)#
			### Add black circles for locations of the input coordinates#
			plot(points.sp,add=T,pch=20)#
			### Add text/legend to show what the green crosshairs are#
			mtext("+ = coordinates written to output.path (if set)",col="green",adj=0,line=1.5,cex=0.8)#
			mtext(paste0("P:A fractal dimension of area inscribed by output coordinates",round(fractal.dimension,digits=3)),adj=0,line=0.5,cex=0.8)#
			### Add map axes#
			maps::map.axes()#
		} else {#
			plot(SpatialPoints(outer),col="white")#
			extent.sp <- SpatialPoints(rbind(outer,coords))#
			plot(spdf_world_10,add=T)#
			plot(SpatialPoints(outer),col="green",add=T)#
			plot(points.sp,add=T,pch=20)#
			mtext("+ outer (coordinates written to output.path)",col="green",adj=0.1,line=0.25,cex=0.8)#
			maps::map.axes()#
		}#
	}#
	### Write outer file to output.path#
	if(!is.null(output.path)){#
		write.table(outer,output.path,row.names=F,col.names=F,sep=" ",quote=F)#
	}#
	### return a list including a matrix of the coordinates in the output file and a SpatialPolygons object of the output coordinates#
	list(outer,outer.poly)#
}
test <- create.outer(coords="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Katie/mainland_maculilabris.coord",method=2,max.fractal.dimension=1.105)
?ploidy()
dev.off()
library(devtools)
devtools::install_github("JeffWeinell/misc.wrappers",auth_token="323d9e4cd00247a39a805dbb66f37db6403cfb8b")
library(misc.wrappers)
test <- runEEMs_snps(input.data="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/Oxyrhabdium_populations.snps_28Feb2021.vcf",coord="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/Oxyrhabdium.coord",output.dirpath="/Users/alyssaleinweber/Documents/Chapter3_Oxyrhabdium/EEMS/EEMS_Oxyrhabdium")
setwd("Documents/misc.wrappers")
devtools::document()
